<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PDA Multiplayer</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #0a0a0f; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            color: #e6edf3;
            overflow: hidden;
        }
        #gameCanvas {
            border: 2px solid #30363d;
            border-radius: 8px;
        }
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 14px;
            color: #e6edf3;
            font-family: 'Consolas', monospace;
            line-height: 1.8;
            background: rgba(13, 17, 23, 0.85);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid #30363d;
            min-width: 280px;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #8b949e;
            font-size: 13px;
            background: rgba(13, 17, 23, 0.85);
            padding: 10px 20px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }
    </style>
</head>
<body>
    <div id="ui"></div>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">WASD: ì´ë™ | E: ëŒ€ì‹œ | Q: ê¶ | F: í•´í‚¹(í™€ë“œ) | B: ê·€í™˜(í™€ë“œ) | í´ë¦­: ê³µê²© | 1/2: ë¬´ê¸° êµì²´(ë² ì´ìŠ¤) | 3: ë¬´ê¸° ë ˆë²¨ì—… | R: ì¬ì‹œì‘</div>

    <script>
    // ==================== CONFIG ====================
    const CONFIG = {
        // ë§µ (ë¯¸í„° ë‹¨ìœ„)
        MAP_WIDTH: 210,
        MAP_HEIGHT: 210,
        
        // ìŠ¤ì¼€ì¼
        SCALE: 25,  // 1m = 25px
        
        // í™”ë©´ (í”½ì…€)
        SCREEN_WIDTH: 1600,
        SCREEN_HEIGHT: 900,
        
        // ê²Œì„
        TPS: 60,
        
        // í”Œë ˆì´ì–´
        PLAYER_RADIUS: 0.5,    // ë¯¸í„° (ì‹¤ì œ ì‚¬ëŒ í¬ê¸°)
        PLAYER_SPEED: 8,       // m/s (ë‹¬ë¦¬ê¸° ì†ë„)
        ATTACK_RANGE: 10,      // ë¯¸í„°
        ATTACK_DAMAGE: 10,
        ATTACK_COOLDOWN: 0.5,  // ì´ˆ
        
        // ë„ë¡œ
        LANE_WIDTH: 15,        // ë¯¸í„°
        
        // ì±„ë„ë§
        CHANNEL_RANGE: 1,      // ë…¸ë“œì—ì„œ 1ë¯¸í„° ì´ë‚´ (ì‹¤ì œ ì±„ë„ë§ ê°€ëŠ¥ ê±°ë¦¬)
        AI_NODE_DETECT_RANGE: 3,  // AIê°€ ë…¸ë“œ ì¸ì‹í•˜ëŠ” ë²”ìœ„ (ë¯¸í„°)
        CHANNEL_FAIL_DELAY: 2, // ì±„ë„ë§ ì‹¤íŒ¨ ì‹œ í›„ë”œë ˆì´ (ì´ˆ)
        
        // ë³´í˜¸ë§‰ ìˆ˜ì‹: S(L) = 40 + 10 Ã— L
        SHIELD_BASE: 40,
        SHIELD_PER_LEVEL: 10,
        
        // XP ì‹œìŠ¤í…œ
        KILL_XP: 4,
        XP_PER_LEVEL: 12,
        MAX_LEVEL: 5,
        
        // ê¸°ë³¸ ì´ë™ì†ë„ (ë¬´ê¸° ë°°ìœ¨ ì ìš© ì „)
        BASE_SPEED: 3,  // m/s (ì¡°ê¹… ì†ë„ ê¸°ì¤€)
        
        // ì‹œì•¼
        VISION_RANGE: 18,  // ì „ì¥ì˜ ì•ˆê°œ
        
        // ê·€í™˜/íšŒë³µ
        RECALL_TIME: 4,      // ê·€í™˜ ì±„ë„ë§ (ì´ˆ)
        BASE_HEAL_RATE: 20,  // ë² ì´ìŠ¤ ê·¼ì²˜ ì´ˆë‹¹ íšŒë³µëŸ‰
        
        // ë¯¸ë‹ˆë§µ
        MINIMAP_SIZE: 180,
        MINIMAP_MARGIN: 20,
    };
    
    // ë¬´ê¸° ìŠ¤í™
    // ë¬´ê¸° ìŠ¤í™ (Budget = 1186 ë™ì¼)
    const WEAPON_SPECS = {
        'melee': {
            speedMult: 1.8,    // ì´ë™ì†ë„ ë°°ìœ¨ (ë¹ ë¦„)
            range: 3,          // ì‚¬ê±°ë¦¬ (ì§„ì§œ ê·¼ì ‘)
            dpsMult: 0.85,     // DPS ë°°ìœ¨
            shieldMult: 0.8,   // ë³´í˜¸ë§‰ ë°°ìœ¨ (ë‚®ìŒ)
            armor: 0.2,        // ë°©ì–´ë ¥ 20% (í›„ë”œ ì¤‘ í”¼í•´ê°ì†Œ)
            dashDist: 4,       // ëŒ€ì‹œ ê±°ë¦¬ (ì§§ìŒ)
            dashCool: 3,       // ëŒ€ì‹œ ì¿¨ë‹¤ìš´ (ì§§ìŒ)
            ultRadius: 8,      // ê¶ ë²”ìœ„ (ë‚´ ì£¼ë³€)
            ultDamage: 40,     // ê¶ ë°ë¯¸ì§€
            ultCool: 20,       // ê¶ ì¿¨ë‹¤ìš´
        },
        'ranged': {
            speedMult: 1.4,    // ì´ë™ì†ë„ ë°°ìœ¨ (ëŠë¦¼)
            range: 14,         // ì‚¬ê±°ë¦¬ (ê¸¸ìŒ)
            dpsMult: 0.8,      // DPS ë°°ìœ¨
            shieldMult: 1.2,   // ë³´í˜¸ë§‰ ë°°ìœ¨ (ë†’ìŒ)
            armor: 0.1,        // ë°©ì–´ë ¥ 10%
            dashDist: 7,       // ëŒ€ì‹œ ê±°ë¦¬ (ê¸¸ìŒ)
            dashCool: 8,       // ëŒ€ì‹œ ì¿¨ë‹¤ìš´ (ê¸¸ìŒ)
            ultRadius: 6,      // ê¶ ë²”ìœ„ (ì§€ì • ìœ„ì¹˜)
            ultDamage: 35,     // ê¶ ë°ë¯¸ì§€
            ultCool: 25,       // ê¶ ì¿¨ë‹¤ìš´
        },
    };
    
    const ULT_REQUIRED_LEVEL = 2;  // ê¶ í•´ê¸ˆ ë ˆë²¨
    const ULT_INITIAL_COOL = 10;   // ì´ˆê¸° ì¿¨ë‹¤ìš´
    
    // ìº”ë²„ìŠ¤ í¬ê¸° = í™”ë©´ í¬ê¸°
    const CANVAS_WIDTH = CONFIG.SCREEN_WIDTH;
    const CANVAS_HEIGHT = CONFIG.SCREEN_HEIGHT;
    
    // ì¹´ë©”ë¼
    const camera = {
        x: 0,  // ë¯¸í„° ë‹¨ìœ„
        y: 0,
    };
    
    // ==================== ë„ë¡œ ìœ í‹¸ë¦¬í‹° ====================
    // ì ê³¼ ì„ ë¶„ ì‚¬ì´ ìµœë‹¨ ê±°ë¦¬
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSq = dx * dx + dy * dy;
        
        if (lengthSq === 0) {
            // ì„ ë¶„ì´ ì ì¸ ê²½ìš°
            return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
        }
        
        // íˆ¬ì˜ ë¹„ìœ¨ t (0~1 ì‚¬ì´ë©´ ì„ ë¶„ ìœ„)
        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
        t = Math.max(0, Math.min(1, t));
        
        // ê°€ì¥ ê°€ê¹Œìš´ ì 
        const nearestX = x1 + t * dx;
        const nearestY = y1 + t * dy;
        
        return Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2);
    }
    
    // í”Œë ˆì´ì–´ê°€ ë„ë¡œ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
    function isOnRoad(x, y) {
        const halfWidth = CONFIG.LANE_WIDTH / 2;
        
        for (const [from, to] of NODE_CONNECTIONS) {
            const n1 = NODE_POSITIONS[from];
            const n2 = NODE_POSITIONS[to];
            const dist = pointToSegmentDistance(x, y, n1.x, n1.y, n2.x, n2.y);
            if (dist <= halfWidth) {
                return true;
            }
        }
        return false;
    }
    
    // ê°€ì¥ ê°€ê¹Œìš´ ë„ë¡œ ìœ„ ìœ„ì¹˜ ì°¾ê¸°
    function getNearestRoadPosition(x, y) {
        const halfWidth = CONFIG.LANE_WIDTH / 2;
        let bestX = x, bestY = y;
        let minDist = Infinity;
        
        for (const [from, to] of NODE_CONNECTIONS) {
            const n1 = NODE_POSITIONS[from];
            const n2 = NODE_POSITIONS[to];
            
            // ì„ ë¶„ ìœ„ ê°€ì¥ ê°€ê¹Œìš´ ì  ê³„ì‚°
            const dx = n2.x - n1.x;
            const dy = n2.y - n1.y;
            const lengthSq = dx * dx + dy * dy;
            
            if (lengthSq === 0) continue;
            
            let t = ((x - n1.x) * dx + (y - n1.y) * dy) / lengthSq;
            t = Math.max(0, Math.min(1, t));
            
            const nearestX = n1.x + t * dx;
            const nearestY = n1.y + t * dy;
            const dist = Math.sqrt((x - nearestX) ** 2 + (y - nearestY) ** 2);
            
            if (dist < minDist) {
                minDist = dist;
                // ë„ë¡œ ê°€ì¥ìë¦¬ë¡œ ë°€ì–´ëƒ„
                if (dist > 0) {
                    const ratio = (halfWidth - 0.5) / dist;  // ì•½ê°„ ì•ˆìª½ìœ¼ë¡œ
                    bestX = nearestX + (x - nearestX) * ratio;
                    bestY = nearestY + (y - nearestY) * ratio;
                } else {
                    bestX = nearestX;
                    bestY = nearestY;
                }
            }
        }
        return { x: bestX, y: bestY };
    }
    
    // ==================== ë…¸ë“œ ì •ì˜ (ë¯¸í„° ë‹¨ìœ„) ====================
    const NODE_POSITIONS = {
        // AíŒ€ (ì•„ë˜) - ê°€ë””ì–¸ë§Œ AíŒ€ ì†Œìœ 
        'A_Base': { x: 105, y: 200, tier: 'Base', team: 0, initOwner: 0, initLocked: true },
        'A_Guardian': { x: 105, y: 185, tier: 'Guardian', team: 0, initOwner: 0, initLocked: true },
        'A_T3': { x: 105, y: 165, tier: 'T3', team: 0, initOwner: -1, initLocked: true },
        'A_T2_L': { x: 50, y: 140, tier: 'T2', team: 0, initOwner: -1, initLocked: true },
        'A_T2_R': { x: 160, y: 140, tier: 'T2', team: 0, initOwner: -1, initLocked: true },
        
        // ì¤‘ë¦½ - T1ë§Œ ì²˜ìŒë¶€í„° ì—´ë¦¼
        'T1_L': { x: 35, y: 105, tier: 'T1', team: -1, initOwner: -1, initLocked: false },
        'T1_R': { x: 175, y: 105, tier: 'T1', team: -1, initOwner: -1, initLocked: false },
        'Breaker': { x: 105, y: 105, tier: 'Breaker', team: -1, initOwner: -1, initLocked: true },
        
        // BíŒ€ (ìœ„) - ê°€ë””ì–¸ë§Œ BíŒ€ ì†Œìœ 
        'B_T2_L': { x: 50, y: 70, tier: 'T2', team: 1, initOwner: -1, initLocked: true },
        'B_T2_R': { x: 160, y: 70, tier: 'T2', team: 1, initOwner: -1, initLocked: true },
        'B_T3': { x: 105, y: 45, tier: 'T3', team: 1, initOwner: -1, initLocked: true },
        'B_Guardian': { x: 105, y: 25, tier: 'Guardian', team: 1, initOwner: 1, initLocked: true },
        'B_Base': { x: 105, y: 10, tier: 'Base', team: 1, initOwner: 1, initLocked: true },
    };
    
    const NODE_CONNECTIONS = [
        ['A_Base', 'A_Guardian'],
        ['A_Guardian', 'A_T3'],
        ['A_T3', 'A_T2_L'], ['A_T3', 'A_T2_R'],
        ['A_T3', 'Breaker'],  // ë¯¸ë“œë ˆì¸
        ['A_T2_L', 'T1_L'], ['A_T2_R', 'T1_R'],
        ['T1_L', 'B_T2_L'], ['T1_R', 'B_T2_R'],
        ['B_T2_L', 'B_T3'], ['B_T2_R', 'B_T3'],
        ['Breaker', 'B_T3'],  // ë¯¸ë“œë ˆì¸
        ['B_T3', 'B_Guardian'],
        ['B_Guardian', 'B_Base'],
        // ë¸Œë ˆì´ì»¤ â†” T1, T2 ì—°ê²° (ëŒ€ê°ì„  ë£¨íŠ¸)
        ['T1_L', 'Breaker'], ['T1_R', 'Breaker'],
        ['A_T2_L', 'Breaker'], ['A_T2_R', 'Breaker'],
        ['B_T2_L', 'Breaker'], ['B_T2_R', 'Breaker'],
    ];
    
    // NODE_CONNECTIONSë¥¼ ì–‘ë°©í–¥ ê·¸ë˜í”„ë¡œ ë³€í™˜
    const NODE_GRAPH = {};
    for (const [a, b] of NODE_CONNECTIONS) {
        if (!NODE_GRAPH[a]) NODE_GRAPH[a] = [];
        if (!NODE_GRAPH[b]) NODE_GRAPH[b] = [];
        if (!NODE_GRAPH[a].includes(b)) NODE_GRAPH[a].push(b);
        if (!NODE_GRAPH[b].includes(a)) NODE_GRAPH[b].push(a);
    }
    
    const NODE_SPECS = {
        'Base': { radius: 8, hp: 9999, channelTime: 999, dps: 0, range: 0, value: 0 },
        'Guardian': { radius: 6, hp: 500, channelTime: 9.0, dps: 4.0, range: 10, value: 10 },
        'T3': { radius: 5, hp: 400, channelTime: 9.1, dps: 6.0, range: 14, value: 5 },
        'T2': { radius: 7, hp: 300, channelTime: 6.2, dps: 2.5, range: 8, value: 3 },
        'T1': { radius: 7, hp: 200, channelTime: 3.0, dps: 1.5, range: 5, value: 2 },
        'Breaker': { radius: 5, hp: 0, channelTime: 8.4, dps: 0, range: 0, value: 0 },
    };
    
    // í…”ë ˆí¬íŠ¸ íŒ¨ë„ ì •ì˜
    // ê° ë² ì´ìŠ¤ ì¤‘ì•™ì— 4ê°œ íŒ¨ë„ (2x2 ë°°ì¹˜, ë„“ê²Œ í¼ëœ¨ë¦¼)
    // íŒ¨ë„ ìœ„ì¹˜ëŠ” ì‹¤ì œ ëª©í‘œ ë…¸ë“œ ë°©í–¥ê³¼ ì¼ì¹˜
    const TELEPORT_PANELS = {
        // AíŒ€ ë² ì´ìŠ¤ íŒ¨ë„ (A_Base: 105, 200) - ë„“ê²Œ ë°°ì¹˜
        // A_T2_Lì€ ë¶ì„œìª½, A_T2_Rì€ ë¶ë™ìª½, B_T2ëŠ” ë” ë¶ìª½
        'A_TP_T2L': { x: 97, y: 205, targetNode: 'A_T2_L', team: 0 },   // ë‚¨ì„œ (ì•„êµ° T2L - ì„œìª½ë°©í–¥)
        'A_TP_T2R': { x: 113, y: 205, targetNode: 'A_T2_R', team: 0 },  // ë‚¨ë™ (ì•„êµ° T2R - ë™ìª½ë°©í–¥)
        'A_TP_BT2L': { x: 97, y: 195, targetNode: 'B_T2_L', team: 0 },  // ë¶ì„œ (ì  T2L - ì„œìª½ë°©í–¥)
        'A_TP_BT2R': { x: 113, y: 195, targetNode: 'B_T2_R', team: 0 }, // ë¶ë™ (ì  T2R - ë™ìª½ë°©í–¥)
        // BíŒ€ ë² ì´ìŠ¤ íŒ¨ë„ (B_Base: 105, 10) - ì‹¤ì œ ë°©í–¥ê³¼ ì¼ì¹˜
        // B_T2_Lì€ ë‚¨ì„œìª½, B_T2_Rì€ ë‚¨ë™ìª½, A_T2ëŠ” ë” ë‚¨ìª½
        'B_TP_T2L': { x: 97, y: 15, targetNode: 'B_T2_L', team: 1 },    // ë‚¨ì„œ (ì•„êµ° T2L - ì„œìª½ë°©í–¥)
        'B_TP_T2R': { x: 113, y: 15, targetNode: 'B_T2_R', team: 1 },   // ë‚¨ë™ (ì•„êµ° T2R - ë™ìª½ë°©í–¥)
        'B_TP_AT2L': { x: 97, y: 5, targetNode: 'A_T2_L', team: 1 },    // ë¶ì„œ (ì  T2L - ì„œìª½ë°©í–¥)
        'B_TP_AT2R': { x: 113, y: 5, targetNode: 'A_T2_R', team: 1 },   // ë¶ë™ (ì  T2R - ë™ìª½ë°©í–¥)
    };
    const TELEPORT_PANEL_RADIUS = 2.5;  // íŒ¨ë„ í¬ê¸° (ë¯¸í„°)
    
    // ë¶€ì‰¬ ìœ„ì¹˜ (ëŒ€ì¹­)
    const BUSHES = [
        // T1 ê·¼ì²˜
        { x: 25, y: 105, radius: 6 },   // T1_L ì™¼ìª½
        { x: 185, y: 105, radius: 6 },  // T1_R ì˜¤ë¥¸ìª½
        // T2 ê·¼ì²˜
        { x: 40, y: 130, radius: 5 },   // A_T2_L ì™¼ìª½ì•„ë˜
        { x: 170, y: 130, radius: 5 },  // A_T2_R ì˜¤ë¥¸ìª½ì•„ë˜
        { x: 40, y: 80, radius: 5 },    // B_T2_L ì™¼ìª½ìœ„
        { x: 170, y: 80, radius: 5 },   // B_T2_R ì˜¤ë¥¸ìª½ìœ„
        // T3 ê·¼ì²˜
        { x: 95, y: 155, radius: 5 },   // A_T3 ì™¼ìª½
        { x: 115, y: 155, radius: 5 },  // A_T3 ì˜¤ë¥¸ìª½
        { x: 95, y: 55, radius: 5 },    // B_T3 ì™¼ìª½
        { x: 115, y: 55, radius: 5 },   // B_T3 ì˜¤ë¥¸ìª½
        // ë¸Œë ˆì´ì»¤ ê·¼ì²˜
        { x: 95, y: 115, radius: 5 },   // Breaker ì™¼ìª½ìœ„
        { x: 115, y: 95, radius: 5 },   // Breaker ì˜¤ë¥¸ìª½ì•„ë˜
    ];
    
    // ==================== MULTIPLAYER ====================
    const SERVER_URL = 'https://pda-server-production.up.railway.app';
    let socket = null;
    let isHost = false;
    let mySocketId = null;
    let myPlayerId = 0;
    
    function getMyPlayer() {
        return game.players.find(p => p.id === myPlayerId) || game.players[0];
    }
    
    let gameState = 'menu';  // 'menu', 'lobby', 'playing'
    let lobbyPlayers = [];
    
    // ==================== GAME STATE ====================
    let game = {
        tick: 0,
        time: 0,
        players: [],
        nodes: {},
        phase: 1,
        winner: null,
        // ê°€ë””ì–¸ ì˜êµ¬ ì–¸ë½ í”Œë˜ê·¸
        aGuardianUnlocked: false,
        bGuardianUnlocked: false,
        // íŒ€ XP/ë ˆë²¨
        teams: [
            { xp: 0, level: 1 },  // Team A
            { xp: 0, level: 1 },  // Team B
        ],
        // ê¶ê·¹ê¸° ì´í™íŠ¸
        ultEffects: [],
        // ëŒ€ì‹œ ì´í™íŠ¸
        dashEffects: [],
        // ê³µê²© ì´í™íŠ¸
        attackEffects: [],
        // ì•Œë¦¼ ì‹œìŠ¤í…œ
        notifications: [],
        // ë¸Œë ˆì´ì»¤ ì‹œìŠ¤í…œ
        gHistory: [],           // Gê°’ íˆìŠ¤í† ë¦¬ (ìµœëŒ€ 900ê°œ)
        breakerSpawned: false,  // ë¸Œë ˆì´ì»¤ í™œì„±í™”ë¨
        breakerClaimCount: 0,   // ë¸Œë ˆì´ì»¤ ì ë ¹ íšŸìˆ˜
        firstStalemateTime: -1, // ì²« êµì°© ê°ì§€ ì‹œê°„
    };
    
    // ì…ë ¥ ìƒíƒœ
    const input = {
        w: false, a: false, s: false, d: false,
        f: false,  // ì±„ë„ë§
        e: false,  // ëŒ€ì‹œ
        b: false,  // ê·€í™˜
        q: false,  // ê¶ê·¹ê¸°
        '1': false, '2': false, '3': false,  // ë¬´ê¸° êµì²´/ë ˆë²¨ì—…
        mouseX: 0, mouseY: 0,
        mouseDown: false,
        // ìŠ¤í‚¬ ì¡°ì¤€ ìƒíƒœ
        aimingDash: false,   // Eí‚¤ ì¡°ì¤€ ì¤‘
        aimingUlt: false,    // Qí‚¤ ì¡°ì¤€ ì¤‘
    };
    
    // ==================== ì´ˆê¸°í™” ====================
    function initGame() {
        // ë…¸ë“œ ì´ˆê¸°í™”
        for (const [id, data] of Object.entries(NODE_POSITIONS)) {
            game.nodes[id] = {
                ...data,
                owner: data.initOwner,  // ì´ˆê¸° ì†Œìœ ê¶Œ
                locked: data.initLocked, // ì´ˆê¸° ì ê¸ˆ ìƒíƒœ
                hp: NODE_SPECS[data.tier].hp,
                maxHp: NODE_SPECS[data.tier].hp,
            };
        }
        
        // í”Œë ˆì´ì–´ ì´ˆê¸°í™” (1 í”Œë ˆì´ì–´ + 7 AI)
        // íŒ€ A (0-3) - A_Base(105, 200) ê·¼ì²˜ ë„ë¡œ ìœ„
        for (let i = 0; i < 4; i++) {
            game.players.push({
                id: i,
                team: 0,
                x: 102 + (i % 2) * 6,  // 102, 108, 102, 108 (ë„ë¡œ í­ ë‚´)
                y: 195 - Math.floor(i / 2) * 3,  // 195, 195, 192, 192
                hp: 100,
                maxHp: 100,
                isAI: i !== 0,  // 0ë²ˆë§Œ í”Œë ˆì´ì–´
                level: 1,
                attackCooldown: 0,
                respawnTimer: 0,
                alive: true,
                weaponType: i === 0 ? 'melee' : (i % 2 === 0 ? 'melee' : 'ranged'),  // í”Œë ˆì´ì–´ëŠ” melee, AIëŠ” ì„ì–´ì„œ
                weaponLevel: 1,       // ë¬´ê¸° ë ˆë²¨
                weaponPoints: 0,      // ë¬´ê¸° í¬ì¸íŠ¸
                dashCooldown: 0,  // ëŒ€ì‹œ ì¿¨ë‹¤ìš´
                ultCooldown: ULT_INITIAL_COOL,  // ê¶ ì¿¨ë‹¤ìš´ (ì´ˆê¸°ê°’)
                recalling: false, // ê·€í™˜ ì¤‘
                recallProgress: 0, // ê·€í™˜ ì§„í–‰ë„
                // ì±„ë„ë§ ìƒíƒœ
                channeling: false,
                channelTarget: null,  // ì±„ë„ë§ ì¤‘ì¸ ë…¸ë“œ ID
                channelProgress: 0,   // í˜„ì¬ ì§„í–‰ë„ (ì´ˆ)
                channelTime: 0,       // í•„ìš”í•œ ì´ ì‹œê°„ (ì´ˆ)
                channelShield: 0,     // ì±„ë„ë§ ë³´í˜¸ë§‰ HP
                maxChannelShield: 0,  // ìµœëŒ€ ë³´í˜¸ë§‰ (UIìš©)
                channelCompleted: false, // Fí‚¤ ë—„ ë•Œê¹Œì§€ ì¬ì‹œë„ ë°©ì§€
                stunTimer: 0,         // í›„ë”œë ˆì´ (ìŠ¤í„´)
                hasBreakerbuff: false, // ë¸Œë ˆì´ì»¤ ë²„í”„
                targetNode: null, // AI ëª©í‘œ ë…¸ë“œ
                currentNode: 'A_Guardian', // AI í˜„ì¬ ë…¸ë“œ
            });
        }
        
        // íŒ€ B (4-7) - B_Base(105, 10) ê·¼ì²˜ ë„ë¡œ ìœ„
        for (let i = 0; i < 4; i++) {
            game.players.push({
                id: i + 4,
                team: 1,
                x: 102 + (i % 2) * 6,  // 102, 108, 102, 108 (ë„ë¡œ í­ ë‚´)
                y: 15 + Math.floor(i / 2) * 3,  // 15, 15, 18, 18
                hp: 100,
                maxHp: 100,
                isAI: true,
                level: 1,
                attackCooldown: 0,
                respawnTimer: 0,
                alive: true,
                weaponType: i % 2 === 0 ? 'melee' : 'ranged',  // AIëŠ” ì„ì–´ì„œ
                weaponLevel: 1,       // ë¬´ê¸° ë ˆë²¨
                weaponPoints: 0,      // ë¬´ê¸° í¬ì¸íŠ¸
                dashCooldown: 0,  // ëŒ€ì‹œ ì¿¨ë‹¤ìš´
                ultCooldown: ULT_INITIAL_COOL,  // ê¶ ì¿¨ë‹¤ìš´ (ì´ˆê¸°ê°’)
                recalling: false, // ê·€í™˜ ì¤‘
                recallProgress: 0, // ê·€í™˜ ì§„í–‰ë„
                // ì±„ë„ë§ ìƒíƒœ
                channeling: false,
                channelTarget: null,
                channelProgress: 0,
                channelTime: 0,
                channelShield: 0,
                maxChannelShield: 0,
                channelCompleted: false, // Fí‚¤ ë—„ ë•Œê¹Œì§€ ì¬ì‹œë„ ë°©ì§€
                stunTimer: 0,
                hasBreakerbuff: false, // ë¸Œë ˆì´ì»¤ ë²„í”„
                targetNode: null, // AI ëª©í‘œ ë…¸ë“œ
                currentNode: 'B_Guardian', // AI í˜„ì¬ ë…¸ë“œ
            });
        }
    }
    
    // ==================== ì…ë ¥ ì²˜ë¦¬ ====================
    document.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();
        
        // Eí‚¤ ëŒ€ì‹œ ì¡°ì¤€ í† ê¸€
        if (key === 'e') {
            input.aimingDash = !input.aimingDash;
            input.aimingUlt = false;
            return;
        }
        
        // Qí‚¤ ê¶ê·¹ê¸° ì¡°ì¤€ í† ê¸€
        if (key === 'q') {
            input.aimingUlt = !input.aimingUlt;
            input.aimingDash = false;
            return;
        }
        
        if (key in input) input[key] = true;
        
        // Rí‚¤ë¡œ ë¦¬ìŠ¤íƒ€íŠ¸
        if (key === 'r' && game.winner !== null) {
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            game.tick = 0;
            game.time = 0;
            game.players = [];
            game.nodes = {};
            game.winner = null;
            game.aGuardianUnlocked = false;
            game.bGuardianUnlocked = false;
            game.teams = [
                { xp: 0, level: 1 },
                { xp: 0, level: 1 },
            ];
            game.ultEffects = [];
            game.dashEffects = [];
            game.attackEffects = [];
            // ë¸Œë ˆì´ì»¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            game.gHistory = [];
            game.breakerSpawned = false;
            game.breakerClaimCount = 0;
            game.firstStalemateTime = -1;
            initGame();
        }
    });
    
    document.addEventListener('keyup', e => {
        const key = e.key.toLowerCase();
        if (key in input) input[key] = false;
    });
    
    document.addEventListener('mousemove', e => {
        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        input.mouseX = e.clientX - rect.left;
        input.mouseY = e.clientY - rect.top;
    });
    
    document.addEventListener('mousedown', () => input.mouseDown = true);
    document.addEventListener('mouseup', () => input.mouseDown = false);
    
    // ==================== ì—…ë°ì´íŠ¸ ====================
    function update(dt) {
        // ìŠ¹ë¦¬ ì‹œ ì •ì§€
        if (game.winner !== null) return;
        
        game.tick++;
        game.time += dt;
        
        // ë¸Œë ˆì´ì»¤ ì‹œìŠ¤í…œ: Gê°’ ê¸°ë¡ + êµì°© ì²´í¬ (1ì´ˆë§ˆë‹¤)
        if (game.tick % 60 === 0) { // 60fps ê¸°ì¤€ 1ì´ˆë§ˆë‹¤
            const g = calculateG();
            game.gHistory.push(g);
            // ìµœëŒ€ 900ê°œ ìœ ì§€
            if (game.gHistory.length > 900) {
                game.gHistory.shift();
            }
            // êµì°© ê°ì§€ â†’ ë¸Œë ˆì´ì»¤ í™œì„±í™”
            spawnBreakerIfNeeded();
        }
        
        for (const p of game.players) {
            if (!p.alive) {
                p.respawnTimer -= dt;
                if (p.respawnTimer <= 0) {
                    respawn(p);
                }
                continue;
            }
            
            if (p.isAI) {
                updateAI(p, dt);
            } else {
                updatePlayer(p, dt);
            }
            
            // ì¿¨ë‹¤ìš´ ê°ì†Œ (AI/í”Œë ˆì´ì–´ ê³µí†µ)
            if (p.attackCooldown > 0) {
                p.attackCooldown -= dt;
            }
            if (p.dashCooldown > 0) {
                p.dashCooldown -= dt;
            }
            if (p.ultCooldown > 0) {
                p.ultCooldown -= dt;
            }
        }
        
        // íƒ€ì›Œ ê³µê²©
        updateTowerAttacks(dt);
        
        // ë…¸ë“œ ì ê¸ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
        updateNodeLocks();
        
        // ë‹¤ì¤‘ ì±„ë„ë§ ì²˜ë¦¬
        updateMultiChanneling(dt);
        
        // ì¹´ë©”ë¼ê°€ í”Œë ˆì´ì–´ ë”°ë¼ê°
        const me = getMyPlayer();
        camera.x = me.x - (CONFIG.SCREEN_WIDTH / CONFIG.SCALE) / 2;
        camera.y = me.y - (CONFIG.SCREEN_HEIGHT / CONFIG.SCALE) / 2;
        
        // ì¹´ë©”ë¼ ë§µ ê²½ê³„ ì œí•œ
        camera.x = Math.max(0, Math.min(CONFIG.MAP_WIDTH - CONFIG.SCREEN_WIDTH / CONFIG.SCALE, camera.x));
        camera.y = Math.max(0, Math.min(CONFIG.MAP_HEIGHT - CONFIG.SCREEN_HEIGHT / CONFIG.SCALE, camera.y));
        
        // ê¶ê·¹ê¸° ì´í™íŠ¸ ì—…ë°ì´íŠ¸
        for (let i = game.ultEffects.length - 1; i >= 0; i--) {
            game.ultEffects[i].timer -= dt;
            if (game.ultEffects[i].timer <= 0) {
                game.ultEffects.splice(i, 1);
            }
        }
        
        // ëŒ€ì‹œ ì´í™íŠ¸ ì—…ë°ì´íŠ¸
        for (let i = game.dashEffects.length - 1; i >= 0; i--) {
            game.dashEffects[i].timer -= dt;
            if (game.dashEffects[i].timer <= 0) {
                game.dashEffects.splice(i, 1);
            }
        }
        
        // ê³µê²© ì´í™íŠ¸ ì—…ë°ì´íŠ¸
        for (let i = game.attackEffects.length - 1; i >= 0; i--) {
            game.attackEffects[i].timer -= dt;
            if (game.attackEffects[i].timer <= 0) {
                game.attackEffects.splice(i, 1);
            }
        }
        
        // ì•Œë¦¼ ì—…ë°ì´íŠ¸
        for (let i = game.notifications.length - 1; i >= 0; i--) {
            game.notifications[i].timer -= dt;
            if (game.notifications[i].timer <= 0) {
                game.notifications.splice(i, 1);
            }
        }
    }
    
    function updateTowerAttacks(dt) {
        // ê° ë…¸ë“œê°€ ë²”ìœ„ ë‚´ ì ì—ê²Œ DPS ë¶„ì‚° ê³µê²©
        for (const [id, node] of Object.entries(game.nodes)) {
            const spec = NODE_SPECS[node.tier];
            
            // ì¤‘ë¦½ì´ê±°ë‚˜ DPS ì—†ìœ¼ë©´ ìŠ¤í‚µ
            if (node.owner === -1 || spec.dps <= 0) continue;
            
            // ë²”ìœ„ ë‚´ ì  ì°¾ê¸°
            const enemyTeam = 1 - node.owner;
            const enemiesInRange = [];
            
            for (const p of game.players) {
                if (p.team !== enemyTeam || !p.alive) continue;
                if (distance(p, node) < spec.range) {
                    enemiesInRange.push(p);
                }
            }
            
            if (enemiesInRange.length === 0) continue;
            
            // DPS ë¶„ì‚°
            let dpsPerTarget = spec.dps / enemiesInRange.length;
            
            for (const p of enemiesInRange) {
                // ì±„ë„ë§ ì¤‘ì´ë©´ íƒ€ì›Œ ëŒ€ë¯¸ì§€ ë©´ì—­
                if (p.channeling) continue;
                
                // ë¸Œë ˆì´ì»¤ ë²„í”„: ë°›ëŠ” ë…¸ë“œ DPS ê°ì†Œ
                let damage = dpsPerTarget * dt;
                if (p.hasBreakerbuff) {
                    damage *= (1 - getBreakerbuff());
                }
                
                p.hp -= damage;
                
                if (p.hp <= 0) {
                    p.alive = false;
                    p.hp = 0;
                    const targetTeamLevel = getTeamLevel(p.team);
                    p.respawnTimer = 6 + 2 * targetTeamLevel;
                    cancelChanneling(p);
                    // íƒ€ì›Œ í‚¬ì€ XP ì—†ìŒ
                }
            }
        }
    }
    
    function updateNodeLocks() {
        // T1_L ì ë ¹ â†’ A_T2_L, B_T2_L ì–¸ë½
        if (game.nodes['T1_L'].owner !== -1) {
            game.nodes['A_T2_L'].locked = false;
            game.nodes['B_T2_L'].locked = false;
        }
        
        // T1_R ì ë ¹ â†’ A_T2_R, B_T2_R ì–¸ë½
        if (game.nodes['T1_R'].owner !== -1) {
            game.nodes['A_T2_R'].locked = false;
            game.nodes['B_T2_R'].locked = false;
        }
        
        // A_T2 ì¤‘ í•˜ë‚˜ ì ë ¹ â†’ A_T3 ì–¸ë½
        if (game.nodes['A_T2_L'].owner !== -1 || game.nodes['A_T2_R'].owner !== -1) {
            game.nodes['A_T3'].locked = false;
        }
        
        // B_T2 ì¤‘ í•˜ë‚˜ ì ë ¹ â†’ B_T3 ì–¸ë½
        if (game.nodes['B_T2_L'].owner !== -1 || game.nodes['B_T2_R'].owner !== -1) {
            game.nodes['B_T3'].locked = false;
        }
        
        // BreakerëŠ” êµì°© ê°ì§€ ì‹œ unlock (spawnBreakerIfNeededì—ì„œ ì²˜ë¦¬)
        
        // BíŒ€ì´ A_T3 ì ë ¹ â†’ A_Guardian ì˜êµ¬ ì–¸ë½
        if (game.nodes['A_T3'].owner === 1) {
            game.aGuardianUnlocked = true;
        }
        
        // AíŒ€ì´ B_T3 ì ë ¹ â†’ B_Guardian ì˜êµ¬ ì–¸ë½
        if (game.nodes['B_T3'].owner === 0) {
            game.bGuardianUnlocked = true;
        }
        
        // ì˜êµ¬ ì–¸ë½ ì ìš©
        if (game.aGuardianUnlocked) {
            game.nodes['A_Guardian'].locked = false;
        }
        if (game.bGuardianUnlocked) {
            game.nodes['B_Guardian'].locked = false;
        }
    }
    
    function updatePlayer(p, dt) {
        // ìŠ¤í„´ ì¤‘ì´ë©´ ì•„ë¬´ê²ƒë„ ëª»í•¨
        if (p.stunTimer > 0) {
            p.stunTimer -= dt;
            return;
        }
        
        // ë¬´ê¸° êµì²´ (ë² ì´ìŠ¤ì—ì„œë§Œ)
        if (isAtBase(p)) {
            if (input['1']) p.weaponType = 'melee';
            if (input['2']) p.weaponType = 'ranged';
            
            // ë² ì´ìŠ¤ ê·¼ì²˜ HP íšŒë³µ
            if (p.hp < p.maxHp) {
                p.hp = Math.min(p.maxHp, p.hp + CONFIG.BASE_HEAL_RATE * dt);
            }
        }
        
        // ë¬´ê¸° ë ˆë²¨ íˆ¬ì (3í‚¤, ì–´ë””ì„œë‚˜ ê°€ëŠ¥)
        if (input['3'] && p.weaponPoints > 0) {
            p.weaponLevel++;
            p.weaponPoints--;
            input['3'] = false;  // í•œë²ˆë§Œ ì‹¤í–‰
        }
        
        // Bí‚¤ ëˆ„ë¥´ë©´ ê·€í™˜
        if (input.b && !isAtBase(p) && !p.channeling && !p.recalling) {
            p.recalling = true;
            p.recallProgress = 0;
        }
        
        // ê·€í™˜ ì¤‘ì´ë©´
        if (p.recalling) {
            // Bí‚¤ ë–¼ê±°ë‚˜ ì´ë™í•˜ë©´ ì·¨ì†Œ
            if (!input.b || input.w || input.a || input.s || input.d) {
                p.recalling = false;
                p.recallProgress = 0;
            } else {
                // ê·€í™˜ ì§„í–‰
                p.recallProgress += dt;
                
                // ê·€í™˜ ì™„ë£Œ
                if (p.recallProgress >= CONFIG.RECALL_TIME) {
                    const baseId = p.team === 0 ? 'A_Base' : 'B_Base';
                    const base = game.nodes[baseId];
                    p.x = base.x;
                    p.y = base.y + (p.team === 0 ? -10 : 10);
                    p.hp = p.maxHp;
                    p.recalling = false;
                    p.recallProgress = 0;
                }
            }
            return;
        }
        
        // Fí‚¤ ëˆ„ë¥´ë©´ ì±„ë„ë§ ì‹œë„ (ì±„ë„ë§ ì¤‘ ì•„ë‹ ë•Œë§Œ)
        if (input.f && !p.channeling && !p.channelCompleted) {
            tryStartChanneling(p);
        }
        
        // Fí‚¤ ë–¼ë©´ channelCompleted ë¦¬ì…‹
        if (!input.f) {
            p.channelCompleted = false;
        }
        
        // ì±„ë„ë§ ì¤‘ì´ë©´
        if (p.channeling) {
            // Fí‚¤ ë–¼ë©´ ì·¨ì†Œ + í›„ë”œë ˆì´ (ë‹¤ë¥¸ ì…ë ¥ì€ ë¬´ì‹œ)
            if (!input.f) {
                failChanneling(p);
            } else {
                // ì±„ë„ë§ ì§„í–‰
                p.channelProgress += dt;
                
                // ì±„ë„ë§ ì™„ë£Œ
                if (p.channelProgress >= p.channelTime) {
                    completeChanneling(p);
                    p.channelCompleted = true;  // F ë—„ ë•Œê¹Œì§€ ì¬ì‹œë„ ë°©ì§€
                }
            }
            return;
        }
        
        // Qí‚¤ ê¶ê·¹ê¸° ì¡°ì¤€ í† ê¸€
        if (input.q && p.ultCooldown <= 0 && getTeamLevel(p.team) >= ULT_REQUIRED_LEVEL) {
            input.aimingUlt = !input.aimingUlt;
            input.aimingDash = false;  // ë‹¤ë¥¸ ì¡°ì¤€ ì·¨ì†Œ
            input.q = false;
        }
        
        // Eí‚¤ ëŒ€ì‹œ ì¡°ì¤€ í† ê¸€
        if (input.e && p.dashCooldown <= 0) {
            input.aimingDash = !input.aimingDash;
            input.aimingUlt = false;  // ë‹¤ë¥¸ ì¡°ì¤€ ì·¨ì†Œ
            input.e = false;
        }
        
        // í´ë¦­ìœ¼ë¡œ ìŠ¤í‚¬ ë°œë™
        if (input.mouseDown) {
            const mouseWorldX = camera.x + input.mouseX / CONFIG.SCALE;
            const mouseWorldY = camera.y + input.mouseY / CONFIG.SCALE;
            
            // ê¶ê·¹ê¸° ë°œë™
            if (input.aimingUlt && p.ultCooldown <= 0 && getTeamLevel(p.team) >= ULT_REQUIRED_LEVEL) {
                const spec = WEAPON_SPECS[p.weaponType];
                let ultX, ultY;
                
                if (p.weaponType === 'melee') {
                    ultX = p.x;
                    ultY = p.y;
                } else {
                    ultX = mouseWorldX;
                    ultY = mouseWorldY;
                }
                
                // ë²”ìœ„ ë‚´ ì ì—ê²Œ ë°ë¯¸ì§€
                for (const enemy of game.players) {
                    if (enemy.team === p.team || !enemy.alive) continue;
                    if (distance({x: ultX, y: ultY}, enemy) < spec.ultRadius) {
                        const armor = WEAPON_SPECS[enemy.weaponType].armor;
                        const finalDamage = spec.ultDamage * (1 - armor);
                        enemy.hp -= finalDamage;
                        
                        if (enemy.recalling) {
                            enemy.recalling = false;
                            enemy.recallProgress = 0;
                        }
                        if (enemy.channeling) {
                            failChanneling(enemy);
                        }
                        
                        if (enemy.hp <= 0) {
                            enemy.alive = false;
                            enemy.hp = 0;
                            const targetTeamLevel = getTeamLevel(enemy.team);
                            enemy.respawnTimer = 6 + 2 * targetTeamLevel;
                            addTeamXP(p.team, CONFIG.KILL_XP);
                        }
                    }
                }
                
                game.ultEffects.push({
                    x: ultX,
                    y: ultY,
                    radius: spec.ultRadius,
                    team: p.team,
                    timer: 0.5,
                });
                
                p.ultCooldown = spec.ultCool;
                input.aimingUlt = false;
                input.mouseDown = false;
                return;
            }
            
            // ëŒ€ì‹œ ë°œë™
            if (input.aimingDash && p.dashCooldown <= 0) {
                const spec = WEAPON_SPECS[p.weaponType];
                
                let dirX = mouseWorldX - p.x;
                let dirY = mouseWorldY - p.y;
                const len = Math.sqrt(dirX * dirX + dirY * dirY);
                
                if (len > 0) {
                    const dx = (dirX / len) * spec.dashDist;
                    const dy = (dirY / len) * spec.dashDist;
                    
                    const startX = p.x;
                    const startY = p.y;
                    
                    let dashX = p.x + dx;
                    let dashY = p.y + dy;
                    
                    if (!isOnRoad(dashX, dashY)) {
                        const nearest = getNearestRoadPosition(dashX, dashY);
                        dashX = nearest.x;
                        dashY = nearest.y;
                    }
                    
                    dashX = Math.max(5, Math.min(CONFIG.MAP_WIDTH - 5, dashX));
                    dashY = Math.max(5, Math.min(CONFIG.MAP_HEIGHT - 5, dashY));
                    
                    p.x = dashX;
                    p.y = dashY;
                    p.dashCooldown = spec.dashCool;
                    
                    game.dashEffects.push({
                        x1: startX,
                        y1: startY,
                        x2: dashX,
                        y2: dashY,
                        team: p.team,
                        timer: 0.2,
                    });
                }
                
                input.aimingDash = false;
                input.mouseDown = false;
                return;
            }
        }
        
        // ì´ë™ ë°©í–¥ ê³„ì‚°
        let vx = 0, vy = 0;
        if (input.w) vy -= 1;
        if (input.s) vy += 1;
        if (input.a) vx -= 1;
        if (input.d) vx += 1;
        
        // ì´ë™ (ë¬´ê¸°ë³„ ì†ë„)
        const speed = getPlayerSpeed(p);
        
        if (vx !== 0 || vy !== 0) {
            const len = Math.sqrt(vx * vx + vy * vy);
            vx = (vx / len) * speed;
            vy = (vy / len) * speed;
        }
        
        const newX = p.x + vx * dt;
        const newY = p.y + vy * dt;
        
        // ë„ë¡œ ìœ„ì¸ì§€ í™•ì¸
        if (isOnRoad(newX, newY)) {
            p.x = newX;
            p.y = newY;
        } else {
            // ë„ë¡œ ë°–ì´ë©´ ê°€ì¥ ê°€ê¹Œìš´ ë„ë¡œ ìœ„ì¹˜ë¡œ
            const nearest = getNearestRoadPosition(newX, newY);
            p.x = nearest.x;
            p.y = nearest.y;
        }
        
        // ë§µ ê²½ê³„
        p.x = Math.max(5, Math.min(CONFIG.MAP_WIDTH - 5, p.x));
        p.y = Math.max(5, Math.min(CONFIG.MAP_HEIGHT - 5, p.y));
        
        // í…”ë ˆí¬íŠ¸ íŒ¨ë„ ì²´í¬ (ì´ë™ í›„)
        checkAndTeleport(p);
        
        // ê³µê²©
        if (input.mouseDown && p.attackCooldown <= 0) {
            tryAttack(p);
        }
    }
    
    // ==================== ìœ í‹¸ë¦¬í‹° ====================
    function getShieldAtLevel(level) {
        // S(L) = 40 + 10 Ã— L
        return CONFIG.SHIELD_BASE + CONFIG.SHIELD_PER_LEVEL * level;
    }
    
    function addTeamXP(teamId, amount) {
        const team = game.teams[teamId];
        team.xp += amount;
        
        // ë ˆë²¨ì—… ì²´í¬
        while (team.xp >= CONFIG.XP_PER_LEVEL && team.level < CONFIG.MAX_LEVEL) {
            team.xp -= CONFIG.XP_PER_LEVEL;
            team.level++;
            
            // ë ˆë²¨ì—… ì‹œ íŒ€ì› ì „ì›ì—ê²Œ ë¬´ê¸° í¬ì¸íŠ¸ +1
            for (const p of game.players) {
                if (p.team === teamId) {
                    p.weaponPoints++;
                }
            }
        }
        
        // ìµœëŒ€ ë ˆë²¨ì´ë©´ XP ìº¡
        if (team.level >= CONFIG.MAX_LEVEL) {
            team.xp = Math.min(team.xp, CONFIG.XP_PER_LEVEL - 1);
        }
    }
    
    // ë¬´ê¸° ë ˆë²¨ ë°°ìœ¨ (ë ˆë²¨ë‹¹ +20%)
    function getWeaponLevelMult(weaponLevel) {
        return 1.0 + (weaponLevel - 1) * 0.2;
    }
    
    function getTeamLevel(teamId) {
        return game.teams[teamId].level;
    }
    
    // ==================== ë¸Œë ˆì´ì»¤ ì‹œìŠ¤í…œ ====================
    function getTeamNodeValue(teamId) {
        // íŒ€ì´ ì†Œìœ í•œ ë…¸ë“œì˜ ê°€ì¹˜ í•©ê³„ (ê°€ë””ì–¸ ì œì™¸)
        let total = 0;
        for (const [id, node] of Object.entries(game.nodes)) {
            if (node.owner === teamId && node.tier !== 'Guardian') {
                total += NODE_SPECS[node.tier].value;
            }
        }
        return total;
    }
    
    function calculateG() {
        // G = (ë…¸ë“œê°€ì¹˜A - ë…¸ë“œê°€ì¹˜B) + 2*(ìƒì¡´A - ìƒì¡´B), ì •ê·œí™”
        const nodeA = getTeamNodeValue(0);
        const nodeB = getTeamNodeValue(1);
        
        const aliveA = game.players.filter(p => p.team === 0 && p.alive).length;
        const aliveB = game.players.filter(p => p.team === 1 && p.alive).length;
        
        const rawG = (nodeA - nodeB) + 2 * (aliveA - aliveB);
        return rawG / 20.0; // ì •ê·œí™” (-1 ~ +1 ë²”ìœ„)
    }
    
    function checkStalemate() {
        // êµì°© ì¡°ê±´: í•œ íŒ€ Lv5 ì´ìƒ + ìŠ¤ë…¸ìš°ë³¼ ìƒíƒœ + ë³€í™”ìœ¨ < epsilon
        const TAU = 15;      // 15ì´ˆ
        const EPSILON = 0.07;
        
        const aLv5 = game.teams[0].level >= 5;
        const bLv5 = game.teams[1].level >= 5;
        
        // ìµœì†Œ í•œ íŒ€ì´ Lv5
        if (!aLv5 && !bLv5) return false;
        
        if (game.gHistory.length === 0) return false;
        
        const currentG = game.gHistory[game.gHistory.length - 1];
        
        // ìŠ¤ë…¸ìš°ë³¼ ìƒíƒœ ì²´í¬
        // AíŒ€ Lv5ì´ê³  ìš°ì„¸(g>0)í•œë° ëª» ëëƒ„ / BíŒ€ Lv5ì´ê³  ìš°ì„¸(g<0)í•œë° ëª» ëëƒ„
        let snowballStuck = (aLv5 && currentG > 0) || (bLv5 && currentG < 0);
        
        // ë‘˜ ë‹¤ Lv5ë©´ ì–´ëŠ ìª½ì´ë“  êµì°© ê°€ëŠ¥
        if (aLv5 && bLv5) snowballStuck = true;
        
        if (!snowballStuck) return false;
        
        // ë³€í™”ìœ¨ í™•ì¸ (TAUì´ˆ ë¶„ëŸ‰ í•„ìš”)
        if (game.gHistory.length < TAU) return false;
        
        const recent = game.gHistory.slice(-TAU);
        const halfTau = Math.floor(TAU / 2);
        
        // ì „ë°˜ë¶€ ë³€í™”ìœ¨
        const firstHalf = recent.slice(0, halfTau);
        const dg1 = Math.abs(firstHalf[firstHalf.length - 1] - firstHalf[0]) / halfTau;
        
        // í›„ë°˜ë¶€ ë³€í™”ìœ¨
        const secondHalf = recent.slice(halfTau);
        const dg2 = Math.abs(secondHalf[secondHalf.length - 1] - secondHalf[0]) / halfTau;
        
        return dg1 < EPSILON && dg2 < EPSILON;
    }
    
    function spawnBreakerIfNeeded() {
        if (checkStalemate()) {
            if (game.firstStalemateTime < 0) {
                game.firstStalemateTime = game.time;
            }
            
            if (!game.breakerSpawned) {
                game.breakerSpawned = true;
                // ë¸Œë ˆì´ì»¤ ë…¸ë“œ ì ê¸ˆ í•´ì œ
                if (game.nodes['Breaker']) {
                    game.nodes['Breaker'].locked = false;
                    console.log('ğŸ”“ ë¸Œë ˆì´ì»¤ ë…¸ë“œ í™œì„±í™”! (êµì°© ê°ì§€)');
                }
            }
        }
    }
    
    function getBreakerbuff() {
        // í´ë ˆì„ íšŸìˆ˜ì— ë”°ë¥¸ ë²„í”„ ê³„ì‚°
        const BASE = 0.50;   // 50% ì´ˆê¸°
        const STEP = 0.15;   // í´ë ˆì„ë‹¹ +15%
        const MAX = 0.80;    // ìµœëŒ€ 80%
        
        const count = game.breakerClaimCount;
        if (count === 0) return 0;
        
        const buff = BASE + (count - 1) * STEP;
        return Math.min(buff, MAX);
    }
    
    function teamHasBreakerbuff(teamId) {
        // íŒ€ì› ì¤‘ ë²„í”„ ê°€ì§„ ì‚¬ëŒì´ ìˆìœ¼ë©´ true
        return game.players.some(p => p.team === teamId && p.alive && p.hasBreakerbuff);
    }
    
    function getPlayerSpeed(p) {
        const spec = WEAPON_SPECS[p.weaponType];
        let speed = CONFIG.BASE_SPEED * spec.speedMult;
        
        // ë¸Œë ˆì´ì»¤ ë²„í”„: ì´ë™ì†ë„ ì¦ê°€
        if (p.hasBreakerbuff) {
            speed *= (1 + getBreakerbuff());
        }
        return speed;
    }
    
    function getPlayerRange(p) {
        return WEAPON_SPECS[p.weaponType].range;
    }
    
    function getPlayerDamage(p) {
        // ê¸°ë³¸ ë°ë¯¸ì§€ * ë¬´ê¸° ë°°ìœ¨ * ë¬´ê¸° ë ˆë²¨ ë°°ìœ¨
        const weaponMult = getWeaponLevelMult(p.weaponLevel);
        return CONFIG.ATTACK_DAMAGE * WEAPON_SPECS[p.weaponType].dpsMult * weaponMult;
    }
    
    function getChannelShield(p) {
        const teamLevel = getTeamLevel(p.team);
        const baseShield = getShieldAtLevel(teamLevel);
        const weaponMult = getWeaponLevelMult(p.weaponLevel);
        return baseShield * WEAPON_SPECS[p.weaponType].shieldMult * weaponMult;
    }
    
    function isAtBase(p) {
        // ë² ì´ìŠ¤ ê·¼ì²˜ 20m ì´ë‚´ì¸ì§€ í™•ì¸
        const baseId = p.team === 0 ? 'A_Base' : 'B_Base';
        const base = game.nodes[baseId];
        return distance(p, base) < 20;
    }
    
    // í…”ë ˆí¬íŠ¸ íŒ¨ë„ ê´€ë ¨ í•¨ìˆ˜
    function getTeleportPanelStatus(panelId) {
        // íŒ¨ë„ ìƒíƒœ ë°˜í™˜: 'ally' (ì•„êµ°ì ë ¹, í…”í¬ê°€ëŠ¥), 'enemy' (ì ì ë ¹), 'neutral' (ì¤‘ë¦½)
        const panel = TELEPORT_PANELS[panelId];
        const targetNode = game.nodes[panel.targetNode];
        
        if (targetNode.owner === panel.team) {
            return 'ally';  // ì•„êµ°ì´ ì ë ¹ â†’ í…”í¬ ê°€ëŠ¥
        } else if (targetNode.owner === 1 - panel.team) {
            return 'enemy';  // ì ì´ ì ë ¹
        }
        return 'neutral';  // ì¤‘ë¦½
    }
    
    function canTeleport(p, panelId) {
        // í…”ë ˆí¬íŠ¸ ê°€ëŠ¥ ì—¬ë¶€ ì²´í¬
        const panel = TELEPORT_PANELS[panelId];
        // ë‚´ íŒ€ íŒ¨ë„ì¸ì§€ í™•ì¸
        if (panel.team !== p.team) return false;
        // ëª©í‘œ ë…¸ë“œê°€ ì•„êµ° ì†Œìœ ì¸ì§€ í™•ì¸
        const targetNode = game.nodes[panel.targetNode];
        return targetNode.owner === p.team;
    }
    
    function checkAndTeleport(p) {
        // í”Œë ˆì´ì–´ê°€ íŒ¨ë„ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸í•˜ê³  í…”í¬
        for (const [panelId, panel] of Object.entries(TELEPORT_PANELS)) {
            // ë‚´ íŒ€ íŒ¨ë„ë§Œ
            if (panel.team !== p.team) continue;
            
            // íŒ¨ë„ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
            if (distance(p, panel) < TELEPORT_PANEL_RADIUS) {
                // í…”í¬ ê°€ëŠ¥í•œì§€ í™•ì¸
                if (canTeleport(p, panelId)) {
                    // ëª©í‘œ ë…¸ë“œ ê·¼ì²˜ë¡œ í…”í¬
                    const targetNode = game.nodes[panel.targetNode];
                    p.x = targetNode.x;
                    p.y = targetNode.y;
                    
                    // AI ìƒíƒœ ê°±ì‹ 
                    if (p.isAI) {
                        p.currentNode = panel.targetNode;
                    }
                    
                    return true;  // í…”í¬ë¨
                }
            }
        }
        return false;  // í…”í¬ ì•ˆ ë¨
    }
    
    function getAITeleportTarget(p) {
        // AIê°€ ë² ì´ìŠ¤ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í…”í¬ íŒ¨ë„ ì°¾ê¸°
        // ìš°ì„ ìˆœìœ„: ì  T2 > ì•„êµ° T2 (ê³µê²©ì )
        const prefix = p.team === 0 ? 'A_TP_' : 'B_TP_';
        const enemyT2Prefix = p.team === 0 ? 'B_T2' : 'A_T2';
        
        let bestPanel = null;
        let bestScore = -Infinity;
        
        for (const [panelId, panel] of Object.entries(TELEPORT_PANELS)) {
            if (!panelId.startsWith(prefix)) continue;
            if (!canTeleport(p, panelId)) continue;
            
            // ì  T2 ìš°ì„ 
            const targetNode = game.nodes[panel.targetNode];
            let score = 0;
            
            if (panel.targetNode.startsWith(enemyT2Prefix)) {
                score = 100;  // ì  T2 ìµœìš°ì„ 
            } else {
                score = 50;   // ì•„êµ° T2
            }
            
            if (score > bestScore) {
                bestScore = score;
                bestPanel = panelId;
            }
        }
        
        return bestPanel;
    }
    
    function getPlayerBush(p) {
        // í”Œë ˆì´ì–´ê°€ ìˆëŠ” ë¶€ì‰¬ ì¸ë±ìŠ¤ ë°˜í™˜ (-1ì´ë©´ ë¶€ì‰¬ ë°–)
        for (let i = 0; i < BUSHES.length; i++) {
            const bush = BUSHES[i];
            if (distance(p, bush) < bush.radius) {
                return i;
            }
        }
        return -1;
    }
    
    function isInBush(p) {
        return getPlayerBush(p) !== -1;
    }
    
    function canSeeTarget(observer, target) {
        // ê°™ì€ íŒ€ì´ë©´ í•­ìƒ ë³´ì„
        if (observer.team === target.team) return true;
        
        // íƒ€ê²Ÿì´ ë¶€ì‰¬ ë°–ì´ë©´ ë³´ì„
        const targetBush = getPlayerBush(target);
        if (targetBush === -1) return true;
        
        // íƒ€ê²Ÿì´ ë¶€ì‰¬ ì•ˆì´ë©´, ê°™ì€ ë¶€ì‰¬ì— ìˆì–´ì•¼ ë³´ì„
        const observerBush = getPlayerBush(observer);
        return observerBush === targetBush;
    }
    
    function isVisibleToTeam(target, teamId) {
        // ì•„êµ° ì¤‘ ëˆ„êµ¬ë¼ë„ ë³¼ ìˆ˜ ìˆìœ¼ë©´ ë³´ì„
        for (const p of game.players) {
            if (p.team !== teamId || !p.alive) continue;
            // ì‹œì•¼ ë²”ìœ„ ë‚´
            if (distance(p, target) < CONFIG.VISION_RANGE) {
                // ë¶€ì‰¬ ì²´í¬
                if (canSeeTarget(p, target)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    // ==================== ì±„ë„ë§ ====================
    // ë‹¤ì¤‘ ì±„ë„ë§ ì‹œê°„ ë‹¨ì¶• ê³µì‹
    function multiChannelFactor(n, A = 4, c = 0.25, k = 5) {
        if (n <= 0) return 1.0;
        return c + (1 - c) * Math.exp(-k * Math.pow(n / A, 2));
    }
    
    // ê°™ì€ ë…¸ë“œë¥¼ ì±„ë„ë§ ì¤‘ì¸ ì•„êµ° ìˆ˜ ì¹´ìš´íŠ¸
    function countChannelers(nodeId, teamId) {
        let count = 0;
        for (const p of game.players) {
            if (p.team === teamId && p.alive && p.channeling && p.channelTarget === nodeId) {
                count++;
            }
        }
        return count;
    }
    
    // ë‹¤ì¤‘ ì±„ë„ë§ ì§„í–‰ ì—…ë°ì´íŠ¸ (AIìš©)
    function updateMultiChanneling(dt) {
        // ê° ë…¸ë“œë³„ë¡œ ì±„ë„ë§ ì¤‘ì¸ í”Œë ˆì´ì–´ ì²˜ë¦¬
        for (const [nodeId, node] of Object.entries(game.nodes)) {
            // ì´ ë…¸ë“œë¥¼ ì±„ë„ë§ ì¤‘ì¸ íŒ€ë³„ í”Œë ˆì´ì–´ ëª©ë¡
            const team0Channelers = game.players.filter(p => 
                p.team === 0 && p.alive && p.channeling && p.channelTarget === nodeId && p.isAI
            );
            const team1Channelers = game.players.filter(p => 
                p.team === 1 && p.alive && p.channeling && p.channelTarget === nodeId && p.isAI
            );
            
            // íŒ€ 0 AI ì±„ë„ë§ ì§„í–‰
            if (team0Channelers.length > 0) {
                const factor = multiChannelFactor(team0Channelers.length);
                const baseTime = NODE_SPECS[node.tier].channelTime;
                const effectiveTime = baseTime * factor;
                const progressRate = dt / effectiveTime;
                
                for (const p of team0Channelers) {
                    if (p.hasBreakerbuff) {
                        p.channelProgress += progressRate / (1 - getBreakerbuff());
                    } else {
                        p.channelProgress += progressRate;
                    }
                    
                    if (p.channelProgress >= 1) {
                        completeChanneling(p);
                        break;  // í•œ ëª…ì´ ì™„ë£Œí•˜ë©´ ë¨
                    }
                }
            }
            
            // íŒ€ 1 AI ì±„ë„ë§ ì§„í–‰
            if (team1Channelers.length > 0) {
                const factor = multiChannelFactor(team1Channelers.length);
                const baseTime = NODE_SPECS[node.tier].channelTime;
                const effectiveTime = baseTime * factor;
                const progressRate = dt / effectiveTime;
                
                for (const p of team1Channelers) {
                    if (p.hasBreakerbuff) {
                        p.channelProgress += progressRate / (1 - getBreakerbuff());
                    } else {
                        p.channelProgress += progressRate;
                    }
                    
                    if (p.channelProgress >= 1) {
                        completeChanneling(p);
                        break;
                    }
                }
            }
        }
    }
    
    function canAttackNode(node, teamId) {
        // ì ê¸´ ë…¸ë“œ ë¶ˆê°€
        if (node.locked) return false;
        // ì´ë¯¸ ë‚´ íŒ€ ë…¸ë“œ ë¶ˆê°€
        if (node.owner === teamId) return false;
        // ë² ì´ìŠ¤ ë¶ˆê°€
        if (node.tier === 'Base') return false;
        // ë¸Œë ˆì´ì»¤ëŠ” ì¤‘ë¦½ì¼ ë•Œë§Œ ê°€ëŠ¥
        if (node.tier === 'Breaker' && node.owner !== -1) return false;
        return true;
    }
    
    function tryStartChanneling(p) {
        // ê°€ì¥ ê°€ê¹Œìš´ ì±„ë„ë§ ê°€ëŠ¥í•œ ë…¸ë“œ ì°¾ê¸°
        let nearestNode = null;
        let minDist = Infinity;
        
        for (const [id, node] of Object.entries(game.nodes)) {
            // ì±„ë„ë§ ê°€ëŠ¥ ì—¬ë¶€ ì²´í¬
            if (!canAttackNode(node, p.team)) continue;
            
            const d = distance(p, node);
            if (d < CONFIG.CHANNEL_RANGE && d < minDist) {
                minDist = d;
                nearestNode = id;
            }
        }
        
        if (nearestNode) {
            const node = game.nodes[nearestNode];
            p.channeling = true;
            p.channelTarget = nearestNode;
            p.channelProgress = 0;
            
            // ì±„ë„ë§ ì‹œê°„ (ë¸Œë ˆì´ì»¤ ë²„í”„ ì ìš©)
            let baseTime = NODE_SPECS[node.tier].channelTime;
            if (p.hasBreakerbuff) {
                baseTime *= (1 - getBreakerbuff());  // ë²„í”„ë§Œí¼ ì‹œê°„ ê°ì†Œ
            }
            p.channelTime = baseTime;
            
            p.channelShield = getChannelShield(p);  // íŒ€ ë ˆë²¨ + ë¬´ê¸° ë°°ìœ¨ ì ìš©
            p.maxChannelShield = p.channelShield;  // ìµœëŒ€ê°’ ì €ì¥ (UIìš©)
        }
    }
    
    function cancelChanneling(p) {
        p.channeling = false;
        p.channelTarget = null;
        p.channelProgress = 0;
        p.channelTime = 0;
        p.channelShield = 0;
    }
    
    function failChanneling(p) {
        // ì±„ë„ë§ ì‹¤íŒ¨ - í›„ë”œë ˆì´ ë¶€ì—¬
        const nodeId = p.channelTarget;
        
        cancelChanneling(p);
        p.stunTimer = CONFIG.CHANNEL_FAIL_DELAY;
        
        // ê°™ì€ ë…¸ë“œ ì±„ë„ë§ ì¤‘ì¸ ì•„êµ° ì „ì› ì‹¤íŒ¨
        if (nodeId) {
            for (const ally of game.players) {
                if (ally === p) continue;  // ìê¸° ìì‹ ì€ ì´ë¯¸ ì²˜ë¦¬í•¨
                if (ally.team === p.team && ally.alive && ally.channeling && ally.channelTarget === nodeId) {
                    cancelChanneling(ally);
                    ally.stunTimer = CONFIG.CHANNEL_FAIL_DELAY;
                }
            }
        }
    }
    
    function addNotification(text, color) {
        game.notifications.push({
            text: text,
            color: color,
            timer: 3,  // 3ì´ˆ ë™ì•ˆ í‘œì‹œ
        });
        // ìµœëŒ€ 5ê°œ ìœ ì§€
        if (game.notifications.length > 5) {
            game.notifications.shift();
        }
    }
    
    function completeChanneling(p) {
        const nodeId = p.channelTarget;
        const node = game.nodes[nodeId];
        const spec = NODE_SPECS[node.tier];
        
        // ë…¸ë“œ ì ë ¹
        node.owner = p.team;
        
        // ì•Œë¦¼ ì¶”ê°€
        const teamName = p.team === 0 ? 'ğŸ”µ Blue' : 'ğŸ”´ Red';
        const teamColor = p.team === 0 ? '#3498db' : '#e74c3c';
        addNotification(`${teamName} captured ${nodeId}!`, teamColor);
        
        // ë¸Œë ˆì´ì»¤ ë…¸ë“œ ì ë ¹ ì‹œ íŠ¹ìˆ˜ ì²˜ë¦¬
        if (nodeId === 'Breaker') {
            game.breakerClaimCount++;
            // ì‚´ì•„ìˆëŠ” íŒ€ì› ì „ì›ì—ê²Œ ë²„í”„ ë¶€ì—¬
            for (const ally of game.players) {
                if (ally.team === p.team && ally.alive) {
                    ally.hasBreakerbuff = true;
                }
            }
            console.log(`âš¡ ${p.team === 0 ? 'AíŒ€' : 'BíŒ€'} ë¸Œë ˆì´ì»¤ ì ë ¹! (ë²„í”„: ${Math.round(getBreakerbuff() * 100)}%)`);
        }
        
        // ë…¸ë“œ ì ë ¹ XP íšë“
        addTeamXP(p.team, spec.value);
        
        // ìŠ¹ë¦¬ ì¡°ê±´ ì²´í¬: ì  ê°€ë””ì–¸ ì ë ¹
        if (nodeId === 'B_Guardian' && p.team === 0) {
            game.winner = 0;  // AíŒ€ ìŠ¹ë¦¬
        } else if (nodeId === 'A_Guardian' && p.team === 1) {
            game.winner = 1;  // BíŒ€ ìŠ¹ë¦¬
        }
        
        // ì±„ë„ë§ ì¢…ë£Œ - ìê¸° ìì‹ 
        cancelChanneling(p);
        
        // ê°™ì€ ë…¸ë“œ ì±„ë„ë§ ì¤‘ì¸ ì•„êµ°ë„ ì™„ë£Œ (íŒ¨ë„í‹° ì—†ìŒ)
        for (const ally of game.players) {
            if (ally === p) continue;
            if (ally.team === p.team && ally.alive && ally.channeling && ally.channelTarget === nodeId) {
                cancelChanneling(ally);  // íŒ¨ë„í‹° ì—†ì´ ì¢…ë£Œ
            }
        }
    }
    
    // ==================== ê²½ë¡œ íƒìƒ‰ ====================
    function findNearestNode(x, y) {
        // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œ ì°¾ê¸° (Base ì œì™¸ - ê²½ë¡œíƒìƒ‰ìš©)
        let nearest = null;
        let minDist = Infinity;
        
        for (const [id, node] of Object.entries(game.nodes)) {
            // BaseëŠ” ì œì™¸ (ê²½ë¡œ íƒìƒ‰ì— ë°©í•´ë¨)
            if (id === 'A_Base' || id === 'B_Base') continue;
            
            const d = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
            if (d < minDist) {
                minDist = d;
                nearest = id;
            }
        }
        return nearest;
    }
    
    function findPathAStar(startNode, endNode) {
        // A* ì•Œê³ ë¦¬ì¦˜
        if (startNode === endNode) return [startNode];
        if (!NODE_GRAPH[startNode] || !NODE_GRAPH[endNode]) return [];
        
        const startPos = game.nodes[startNode];
        const endPos = game.nodes[endNode];
        if (!startPos || !endPos) return [];
        
        // íœ´ë¦¬ìŠ¤í‹±: ìœ í´ë¦¬ë“œ ê±°ë¦¬
        function h(nodeId) {
            const node = game.nodes[nodeId];
            if (!node) return Infinity;
            return Math.sqrt((node.x - endPos.x) ** 2 + (node.y - endPos.y) ** 2);
        }
        
        // ë‘ ë…¸ë“œ ê°„ ì‹¤ì œ ê±°ë¦¬
        function edgeCost(a, b) {
            const na = game.nodes[a], nb = game.nodes[b];
            if (!na || !nb) return Infinity;
            return Math.sqrt((na.x - nb.x) ** 2 + (na.y - nb.y) ** 2);
        }
        
        const openSet = new Set([startNode]);
        const cameFrom = {};
        const gScore = { [startNode]: 0 };
        const fScore = { [startNode]: h(startNode) };
        
        while (openSet.size > 0) {
            // fê°’ ìµœì†Œì¸ ë…¸ë“œ ì„ íƒ
            let current = null, minF = Infinity;
            for (const node of openSet) {
                const f = fScore[node] ?? Infinity;
                if (f < minF) { minF = f; current = node; }
            }
            
            if (current === endNode) {
                // ê²½ë¡œ ë³µì›
                const path = [current];
                while (cameFrom[path[0]]) {
                    path.unshift(cameFrom[path[0]]);
                }
                return path;
            }
            
            openSet.delete(current);
            
            for (const neighbor of NODE_GRAPH[current] || []) {
                const tentativeG = (gScore[current] ?? Infinity) + edgeCost(current, neighbor);
                
                if (tentativeG < (gScore[neighbor] ?? Infinity)) {
                    cameFrom[neighbor] = current;
                    gScore[neighbor] = tentativeG;
                    fScore[neighbor] = tentativeG + h(neighbor);
                    openSet.add(neighbor);
                }
            }
        }
        
        return []; // ê²½ë¡œ ì—†ìŒ
    }
    
    function getNextWaypoint(p, targetNodeId) {
        // í˜„ì¬ ìœ„ì¹˜ì—ì„œ íƒ€ê²Ÿ ë…¸ë“œê¹Œì§€ ë‹¤ìŒ ì›¨ì´í¬ì¸íŠ¸ ë°˜í™˜
        const currentNode = findNearestNode(p.x, p.y);
        if (!currentNode) return null;
        
        const targetNode = game.nodes[targetNodeId];
        if (!targetNode) return null;
        
        // ì´ë¯¸ íƒ€ê²Ÿ ë…¸ë“œ ì¶©ë¶„íˆ ê°€ê¹Œìš°ë©´ íƒ€ê²Ÿìœ¼ë¡œ
        const distToTarget = Math.sqrt((p.x - targetNode.x) ** 2 + (p.y - targetNode.y) ** 2);
        if (distToTarget < 5) {
            return targetNode;
        }
        
        if (currentNode === targetNodeId) {
            return targetNode;
        }
        
        const path = findPathAStar(currentNode, targetNodeId);
        if (path.length < 2) {
            // ê²½ë¡œ ì—†ìœ¼ë©´ í˜„ì¬ ë…¸ë“œ ìœ„ì¹˜ë¡œ (ì•ˆì „)
            return game.nodes[currentNode];
        }
        
        // ë‹¤ìŒ ë…¸ë“œê°€ ì›¨ì´í¬ì¸íŠ¸
        const nextNodeId = path[1];
        return game.nodes[nextNodeId];
    }

    // ==================== AI ====================
    
    // ë…¸ë“œ ê°„ ë‹¤ìŒ ê²½ë¡œ (í•˜ë“œì½”ë”©) - getNextNode(from, to)
    const NODE_ROUTES = {
        // AíŒ€ ì „ì§„ ë°©í–¥ (ì•„ë˜ â†’ ìœ„)
        'A_Guardian': { 'A_T3': 'A_T3', 'A_T2_L': 'A_T3', 'A_T2_R': 'A_T3', 'T1_L': 'A_T3', 'T1_R': 'A_T3', 'Breaker': 'A_T3', 'B_T2_L': 'A_T3', 'B_T2_R': 'A_T3', 'B_T3': 'A_T3', 'B_Guardian': 'A_T3' },
        'A_T3': { 'A_T2_L': 'A_T2_L', 'A_T2_R': 'A_T2_R', 'T1_L': 'A_T2_L', 'T1_R': 'A_T2_R', 'Breaker': 'Breaker', 'B_T2_L': 'A_T2_L', 'B_T2_R': 'A_T2_R', 'B_T3': 'Breaker', 'B_Guardian': 'Breaker', 'A_Guardian': 'A_Guardian' },
        'A_T2_L': { 'T1_L': 'T1_L', 'Breaker': 'Breaker', 'B_T2_L': 'T1_L', 'B_T3': 'T1_L', 'B_Guardian': 'T1_L', 'A_T3': 'A_T3', 'A_Guardian': 'A_T3', 'T1_R': 'Breaker', 'A_T2_R': 'Breaker', 'B_T2_R': 'Breaker' },
        'A_T2_R': { 'T1_R': 'T1_R', 'Breaker': 'Breaker', 'B_T2_R': 'T1_R', 'B_T3': 'T1_R', 'B_Guardian': 'T1_R', 'A_T3': 'A_T3', 'A_Guardian': 'A_T3', 'T1_L': 'Breaker', 'A_T2_L': 'Breaker', 'B_T2_L': 'Breaker' },
        'T1_L': { 'B_T2_L': 'B_T2_L', 'B_T3': 'B_T2_L', 'B_Guardian': 'B_T2_L', 'Breaker': 'Breaker', 'A_T2_L': 'A_T2_L', 'A_T3': 'A_T2_L', 'A_Guardian': 'A_T2_L', 'T1_R': 'Breaker', 'A_T2_R': 'Breaker', 'B_T2_R': 'Breaker' },
        'T1_R': { 'B_T2_R': 'B_T2_R', 'B_T3': 'B_T2_R', 'B_Guardian': 'B_T2_R', 'Breaker': 'Breaker', 'A_T2_R': 'A_T2_R', 'A_T3': 'A_T2_R', 'A_Guardian': 'A_T2_R', 'T1_L': 'Breaker', 'A_T2_L': 'Breaker', 'B_T2_L': 'Breaker' },
        'Breaker': { 'A_T3': 'A_T3', 'B_T3': 'B_T3', 'A_T2_L': 'A_T2_L', 'A_T2_R': 'A_T2_R', 'B_T2_L': 'B_T2_L', 'B_T2_R': 'B_T2_R', 'T1_L': 'T1_L', 'T1_R': 'T1_R', 'A_Guardian': 'A_T3', 'B_Guardian': 'B_T3' },
        'B_T2_L': { 'B_T3': 'B_T3', 'B_Guardian': 'B_T3', 'T1_L': 'T1_L', 'Breaker': 'Breaker', 'A_T2_L': 'T1_L', 'A_T3': 'T1_L', 'A_Guardian': 'T1_L', 'T1_R': 'Breaker', 'A_T2_R': 'Breaker', 'B_T2_R': 'Breaker' },
        'B_T2_R': { 'B_T3': 'B_T3', 'B_Guardian': 'B_T3', 'T1_R': 'T1_R', 'Breaker': 'Breaker', 'A_T2_R': 'T1_R', 'A_T3': 'T1_R', 'A_Guardian': 'T1_R', 'T1_L': 'Breaker', 'A_T2_L': 'Breaker', 'B_T2_L': 'Breaker' },
        'B_T3': { 'B_T2_L': 'B_T2_L', 'B_T2_R': 'B_T2_R', 'T1_L': 'B_T2_L', 'T1_R': 'B_T2_R', 'Breaker': 'Breaker', 'A_T2_L': 'B_T2_L', 'A_T2_R': 'B_T2_R', 'A_T3': 'Breaker', 'A_Guardian': 'Breaker', 'B_Guardian': 'B_Guardian' },
        'B_Guardian': { 'B_T3': 'B_T3', 'B_T2_L': 'B_T3', 'B_T2_R': 'B_T3', 'T1_L': 'B_T3', 'T1_R': 'B_T3', 'Breaker': 'B_T3', 'A_T2_L': 'B_T3', 'A_T2_R': 'B_T3', 'A_T3': 'B_T3', 'A_Guardian': 'B_T3' },
    };
    
    function getNextNode(fromId, toId) {
        if (fromId === toId) return toId;
        return NODE_ROUTES[fromId]?.[toId] || toId;
    }
    
    // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œ (Base ì œì™¸)
    function findCurrentNode(p) {
        let nearest = null, minDist = Infinity;
        for (const [id, node] of Object.entries(game.nodes)) {
            if (id === 'A_Base' || id === 'B_Base') continue;
            const d = distance(p, node);
            if (d < minDist) { minDist = d; nearest = id; }
        }
        return nearest;
    }
    
    // ë…¸ë“œ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
    function moveToNode(p, nodeId, speed, dt) {
        const node = game.nodes[nodeId];
        if (!node) return;
        
        const dx = node.x - p.x;
        const dy = node.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 3) {
            // ë„ì°© - í˜„ì¬ ë…¸ë“œ ì—…ë°ì´íŠ¸
            p.currentNode = nodeId;
            return;
        }
        
        // ì´ë™
        const newX = p.x + (dx / dist) * speed * dt;
        const newY = p.y + (dy / dist) * speed * dt;
        
        // ë„ë¡œ ì²´í¬
        if (isOnRoad(newX, newY)) {
            p.x = newX;
            p.y = newY;
        } else {
            // ë„ë¡œ ë°–ì´ë©´ ê°€ì¥ ê°€ê¹Œìš´ ë„ë¡œë¡œ
            const nearest = getNearestRoadPosition(newX, newY);
            p.x = nearest.x;
            p.y = nearest.y;
        }
        
        // ë§µ ê²½ê³„
        p.x = Math.max(15, Math.min(CONFIG.MAP_WIDTH - 15, p.x));
        p.y = Math.max(15, Math.min(CONFIG.MAP_HEIGHT - 15, p.y));
    }
    
    // ììœ ì—ë„ˆì§€ ì ìˆ˜
    function feScore(situation, ideal, beta = 2.0) {
        let dist = 0;
        for (const k in ideal) {
            dist += ((situation[k] || 0) - ideal[k]) ** 2;
        }
        return Math.exp(-beta * dist);
    }
    
    // í™•ë¥ ì  ì„ íƒ
    function feSelect(options) {
        const total = options.reduce((sum, o) => sum + o.score, 0);
        if (total <= 0) return options[0]?.action;
        const r = Math.random() * total;
        let acc = 0;
        for (const o of options) {
            acc += o.score;
            if (r < acc) return o.action;
        }
        return options[0]?.action;
    }
    
    // AI ìƒí™© ê°ì§€
    function detectSituation(p) {
        const enemies = game.players.filter(e => e.team !== p.team && e.alive);
        const allies = game.players.filter(a => a.team === p.team && a.alive && a.id !== p.id);
        
        let nearestEnemy = null, enemyDist = Infinity;
        for (const e of enemies) {
            if (!canSeeTarget(p, e)) continue;
            const d = distance(p, e);
            if (d < enemyDist) { enemyDist = d; nearestEnemy = e; }
        }
        
        const nearbyAllies = allies.filter(a => distance(p, a) < 25).length;
        const nearbyEnemies = enemies.filter(e => distance(p, e) < 25 && canSeeTarget(p, e)).length;
        
        return {
            hpRatio: p.hp / p.maxHp,
            nearestEnemy,
            enemyDist,
            nearbyAllies,
            nearbyEnemies,
            advantage: (nearbyAllies + 1) / Math.max(nearbyEnemies, 1),
            aliveAllies: allies.length + 1,
        };
    }
    
    // ìƒí™©ë³„ ììœ ì—ë„ˆì§€ íŒë‹¨
    function feDecideAction(p, sit) {
        const options = [];
        
        // 1. í›„í‡´ (HP ë‚®ê³  ë¶ˆë¦¬)
        if (sit.hpRatio < 0.4) {
            options.push({
                action: 'retreat',
                score: feScore(
                    { hp: sit.hpRatio, danger: sit.nearbyEnemies / 3 },
                    { hp: 0.15, danger: 0.8 }
                ) * 3
            });
        }
        
        // 2. ê·€í™˜ (HP ë‚®ê³  ì•ˆì „)
        if (sit.hpRatio < 0.4 && sit.enemyDist > 30) {
            options.push({
                action: 'recall',
                score: feScore(
                    { hp: sit.hpRatio, safe: sit.enemyDist > 30 ? 1 : 0 },
                    { hp: 0.2, safe: 1 }
                ) * 2.5
            });
        }
        
        // 3. ê³µê²© (ì  ë°œê²¬ + ìœ ë¦¬)
        if (sit.nearestEnemy && sit.enemyDist < 20) {
            options.push({
                action: 'attack',
                score: feScore(
                    { hp: sit.hpRatio, advantage: Math.min(sit.advantage, 2) / 2 },
                    { hp: 0.5, advantage: 0.7 }
                ) * 2
            });
        }
        
        // 4. ì±„ë„ë§ (ë…¸ë“œ ê·¼ì²˜ + ì•ˆì „)
        options.push({
            action: 'channel',
            score: feScore(
                { hp: sit.hpRatio, safe: sit.enemyDist > 15 ? 1 : 0 },
                { hp: 0.4, safe: 0.9 }
            ) * 2
        });
        
        // 5. ê³„ì† ì´ë™
        options.push({ action: 'move', score: 1.0 });
        
        return feSelect(options);
    }
    
    // ë‹¤ìŒ ëª©í‘œ ë…¸ë“œ ì„ íƒ (ììœ ì—ë„ˆì§€)
    function feSelectTargetNode(p) {
        const breaker = game.nodes['Breaker'];
        const breakerActive = game.breakerSpawned && breaker?.owner === -1;
        const aliveAllies = game.players.filter(x => x.team === p.team && x.alive).length;
        
        // ë¸Œë ˆì´ì»¤ ìš°ì„  (í™œì„±í™” + ì•„êµ° 3ëª… ì´ìƒ)
        if (breakerActive && aliveAllies >= 3 && canAttackNode(breaker, p.team)) {
            return 'Breaker';
        }
        
        // AIë³„ ê³ ì • ë¼ì¸ í• ë‹¹ (id ê¸°ë°˜)
        // íŒ€ A: 0,1,2,3 â†’ íŒ€ B: 4,5,6,7
        // ì§ìˆ˜ id = ì™¼ìª½ ë¼ì¸, í™€ìˆ˜ id = ì˜¤ë¥¸ìª½ ë¼ì¸
        const isLeftLane = p.id % 2 === 0;
        
        // ë¼ì¸ë³„ ë…¸ë“œ ìˆœì„œ (ê³µê²© ë°©í–¥)
        const laneNodes = p.team === 0 
            ? (isLeftLane 
                ? ['A_T2_L', 'T1_L', 'B_T2_L', 'B_T3', 'B_Guardian']
                : ['A_T2_R', 'T1_R', 'B_T2_R', 'B_T3', 'B_Guardian'])
            : (isLeftLane 
                ? ['B_T2_L', 'T1_L', 'A_T2_L', 'A_T3', 'A_Guardian']
                : ['B_T2_R', 'T1_R', 'A_T2_R', 'A_T3', 'A_Guardian']);
        
        // ë¼ì¸ì—ì„œ ê³µê²© ê°€ëŠ¥í•œ ì²« ë²ˆì§¸ ë…¸ë“œ ì„ íƒ
        for (const nodeId of laneNodes) {
            const node = game.nodes[nodeId];
            if (node && canAttackNode(node, p.team)) {
                return nodeId;
            }
        }
        
        // ë¼ì¸ ë…¸ë“œê°€ ë‹¤ ì ë ¹ëìœ¼ë©´ ì  ê°€ë””ì–¸
        const enemyGuardian = p.team === 0 ? 'B_Guardian' : 'A_Guardian';
        if (canAttackNode(game.nodes[enemyGuardian], p.team)) {
            return enemyGuardian;
        }
        
        // ê¸°ë³¸ê°’
        return isLeftLane ? 'T1_L' : 'T1_R';
    }
    
    // ==================== AI ìŠ¤í‚¬ ì‚¬ìš© ====================
    
    // AI ëŒ€ì‹œ - ë°©í–¥ê³¼ í•¨ê»˜ ì‚¬ìš©
    function aiDash(p, dirX, dirY) {
        if (p.dashCooldown > 0) return false;
        
        const spec = WEAPON_SPECS[p.weaponType];
        const len = Math.sqrt(dirX * dirX + dirY * dirY);
        if (len === 0) return false;
        
        const startX = p.x;
        const startY = p.y;
        
        const dx = (dirX / len) * spec.dashDist;
        const dy = (dirY / len) * spec.dashDist;
        
        let dashX = p.x + dx;
        let dashY = p.y + dy;
        
        // ë„ë¡œ ë²”ìœ„ ë‚´ë¡œ ì œí•œ
        if (!isOnRoad(dashX, dashY)) {
            const nearest = getNearestRoadPosition(dashX, dashY);
            dashX = nearest.x;
            dashY = nearest.y;
        }
        
        // ë§µ ê²½ê³„
        dashX = Math.max(5, Math.min(CONFIG.MAP_WIDTH - 5, dashX));
        dashY = Math.max(5, Math.min(CONFIG.MAP_HEIGHT - 5, dashY));
        
        p.x = dashX;
        p.y = dashY;
        p.dashCooldown = spec.dashCool;
        
        // ëŒ€ì‹œ ì´í™íŠ¸ ì¶”ê°€
        game.dashEffects.push({
            x1: startX,
            y1: startY,
            x2: dashX,
            y2: dashY,
            team: p.team,
            timer: 0.2,
        });
        
        return true;
    }
    
    // AI ê¶ê·¹ê¸° - ìµœì  ìœ„ì¹˜ì— ì‚¬ìš©
    function aiUseUlt(p) {
        if (p.ultCooldown > 0) return false;
        if (getTeamLevel(p.team) < ULT_REQUIRED_LEVEL) return false;
        
        const spec = WEAPON_SPECS[p.weaponType];
        let ultX, ultY;
        
        // ê·¼ì²˜ ì  ì°¾ê¸°
        const nearbyEnemies = [];
        for (const enemy of game.players) {
            if (enemy.team === p.team || !enemy.alive) continue;
            if (!canSeeTarget(p, enemy)) continue;
            const d = distance(p, enemy);
            if (d < 20) {
                nearbyEnemies.push({ enemy, dist: d });
            }
        }
        
        if (nearbyEnemies.length === 0) return false;
        
        if (p.weaponType === 'melee') {
            // ê·¼ì ‘: ë‚´ ìœ„ì¹˜ì— ì‚¬ìš© - ì ì´ 1ëª…ì´ë¼ë„ ë²”ìœ„ ë‚´ì— ìˆì–´ì•¼
            const inRange = nearbyEnemies.filter(e => e.dist < spec.ultRadius);
            if (inRange.length === 0) return false;
            ultX = p.x;
            ultY = p.y;
        } else {
            // ì›ê±°ë¦¬: ì  ë°€ì§‘ ì§€ì ì— ì‚¬ìš©
            // ê°€ì¥ ê°€ê¹Œìš´ ì  ìœ„ì¹˜ ê¸°ì¤€
            nearbyEnemies.sort((a, b) => a.dist - b.dist);
            const target = nearbyEnemies[0].enemy;
            ultX = target.x;
            ultY = target.y;
        }
        
        // ë²”ìœ„ ë‚´ ì ì—ê²Œ ë°ë¯¸ì§€
        for (const enemy of game.players) {
            if (enemy.team === p.team || !enemy.alive) continue;
            if (distance({ x: ultX, y: ultY }, enemy) < spec.ultRadius) {
                enemy.hp -= spec.ultDamage;
                
                // í”¼ê²© ì‹œ ê·€í™˜/ì±„ë„ë§ ì·¨ì†Œ
                if (enemy.recalling) {
                    enemy.recalling = false;
                    enemy.recallProgress = 0;
                }
                if (enemy.channeling) {
                    enemy.channelShield -= spec.ultDamage;
                    if (enemy.channelShield <= 0) {
                        failChanneling(enemy);
                    }
                }
                
                // í‚¬ ì²´í¬
                if (enemy.hp <= 0) {
                    enemy.hp = 0;
                    enemy.alive = false;
                    const targetTeamLevel = getTeamLevel(enemy.team);
                    enemy.respawnTimer = 6 + 2 * targetTeamLevel;
                    addTeamXP(p.team, CONFIG.KILL_XP);
                }
            }
        }
        
        // ê¶ ì´í™íŠ¸
        game.ultEffects.push({
            x: ultX,
            y: ultY,
            radius: spec.ultRadius,
            team: p.team,
            timer: 0.5,
        });
        
        p.ultCooldown = spec.ultCool;
        return true;
    }
    
    // ê³µê²© ì‹¤í–‰
    function aiDoAttack(p, target, dt) {
        if (!target || !target.alive) return;
        const range = getPlayerRange(p);
        const d = distance(p, target);
        
        // ë²”ìœ„ ë°–ì´ë©´ ì ‘ê·¼
        if (d > range * 0.9) {
            const dx = target.x - p.x;
            const dy = target.y - p.y;
            const speed = getPlayerSpeed(p);
            p.x += (dx / d) * speed * dt;
            p.y += (dy / d) * speed * dt;
        }
        
        // ê³µê²©
        if (d <= range && p.attackCooldown <= 0) {
            attack(p, target);
        }
    }
    
    // ì±„ë„ë§ ì‹œì‘
    function aiStartChanneling(p, nodeId) {
        const node = game.nodes[nodeId];
        if (!node || !canAttackNode(node, p.team)) return false;
        if (distance(p, node) > CONFIG.CHANNEL_RANGE) return false;
        
        p.channeling = true;
        p.channelTarget = nodeId;
        p.channelProgress = 0;  // 0~1 ê¸°ë°˜
        p.channelTime = NODE_SPECS[node.tier].channelTime;  // UI í‘œì‹œìš© (ì‹¤ì œ ì‹œê°„ì€ ë‹¤ì¤‘ì±„ë„ë§ìœ¼ë¡œ ê³„ì‚°)
        p.channelShield = getChannelShield(p);
        p.maxChannelShield = p.channelShield;
        return true;
    }
    
    // ==================== ë©”ì¸ AI ====================
    function updateAI(p, dt) {
        const speed = getPlayerSpeed(p);
        
        // AI ë¬´ê¸° ë ˆë²¨ íˆ¬ì (í¬ì¸íŠ¸ ìˆìœ¼ë©´ ë°”ë¡œ íˆ¬ì)
        if (p.weaponPoints > 0) {
            p.weaponLevel++;
            p.weaponPoints--;
        }
        
        // ìƒíƒœ ì²˜ë¦¬
        if (p.stunTimer > 0) { p.stunTimer -= dt; return; }
        
        if (p.recalling) {
            p.recallProgress += dt;
            if (p.recallProgress >= CONFIG.RECALL_TIME) {
                const base = game.nodes[p.team === 0 ? 'A_Base' : 'B_Base'];
                p.x = base.x; p.y = base.y;
                p.hp = p.maxHp;
                p.recalling = false;
                p.currentNode = p.team === 0 ? 'A_Guardian' : 'B_Guardian';
                p.targetNode = null;
            }
            return;
        }
        
        if (p.channeling) {
            // ì±„ë„ë§ ì§„í–‰ì€ updateMultiChanneling()ì—ì„œ ì²˜ë¦¬
            return;
        }
        
        // ë² ì´ìŠ¤ì— ìˆì„ ë•Œ í…”í¬ íŒ¨ë„ ì‚¬ìš©
        if (isAtBase(p)) {
            const tpPanel = getAITeleportTarget(p);
            if (tpPanel) {
                const panel = TELEPORT_PANELS[tpPanel];
                // íŒ¨ë„ë¡œ ì´ë™
                const dx = panel.x - p.x;
                const dy = panel.y - p.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                
                if (d < TELEPORT_PANEL_RADIUS) {
                    // íŒ¨ë„ ìœ„ì— ìˆìœ¼ë©´ í…”í¬
                    checkAndTeleport(p);
                    return;
                } else {
                    // íŒ¨ë„ë¡œ ì´ë™
                    p.x += (dx / d) * speed * dt;
                    p.y += (dy / d) * speed * dt;
                    return;
                }
            }
        }
        
        // ìƒí™© ê°ì§€
        const sit = detectSituation(p);
        
        // ===== ìƒí™© ë°œìƒ: ììœ ì—ë„ˆì§€ë¡œ í–‰ë™ ê²°ì • =====
        const inCombat = sit.nearestEnemy && sit.enemyDist < 20;
        const lowHP = sit.hpRatio < 0.4;
        
        // ===== ì  ì—†ìœ¼ë©´ ì±„ë„ë§ ìš°ì„  =====
        if (!inCombat) {
            // ê·¼ì²˜ ì±„ë„ë§ ê°€ëŠ¥í•œ ë…¸ë“œ ì°¾ê¸°
            for (const [id, node] of Object.entries(game.nodes)) {
                if (!canAttackNode(node, p.team)) continue;
                const d = distance(p, node);
                
                // ì±„ë„ë§ ë²”ìœ„ ì•ˆì´ë©´ ë°”ë¡œ ì±„ë„ë§
                if (d < CONFIG.CHANNEL_RANGE) {
                    aiStartChanneling(p, id);
                    return;
                }
                
                // ì¸ì‹ ë²”ìœ„ ì•ˆì´ë©´ ë…¸ë“œë¡œ ì´ë™
                if (d < CONFIG.AI_NODE_DETECT_RANGE) {
                    const dx = node.x - p.x;
                    const dy = node.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        p.x += (dx / dist) * speed * dt;
                        p.y += (dy / dist) * speed * dt;
                    }
                    return;
                }
            }
        }
        
        if (lowHP || inCombat) {
            const action = feDecideAction(p, sit);
            
            if (action === 'retreat') {
                // í›„í‡´ ì‹œ ëª©í‘œ ì´ˆê¸°í™”
                p.targetNode = null;
                const baseNode = p.team === 0 ? 'A_Guardian' : 'B_Guardian';
                
                // HP 30% ì´í•˜ + ì  ê°€ê¹Œìš°ë©´ ëŒ€ì‹œë¡œ ë„ì£¼
                if (sit.hpRatio < 0.3 && sit.nearestEnemy && sit.enemyDist < 10) {
                    const dx = p.x - sit.nearestEnemy.x;
                    const dy = p.y - sit.nearestEnemy.y;
                    aiDash(p, dx, dy);
                }
                
                moveToNode(p, baseNode, speed * 1.2, dt);
                if (sit.nearestEnemy && sit.enemyDist <= getPlayerRange(p) && p.attackCooldown <= 0) {
                    attack(p, sit.nearestEnemy);
                }
                return;
            }
            
            if (action === 'recall') {
                p.recalling = true;
                p.recallProgress = 0;
                return;
            }
            
            if (action === 'attack' && sit.nearestEnemy) {
                // ê¶ê·¹ê¸° ì‚¬ìš© ì¡°ê±´: ì  2ëª… ì´ìƒ ê·¼ì²˜ì— ìˆê±°ë‚˜, ì  HP ë‚®ì„ ë•Œ
                if (sit.nearbyEnemies >= 2 || (sit.nearestEnemy.hp / sit.nearestEnemy.maxHp < 0.4)) {
                    aiUseUlt(p);
                }
                
                // ì ì´ ë„ë§ê°€ë©´ ëŒ€ì‹œë¡œ ì¶”ê²© (ì›ê±°ë¦¬ëŠ” ëœ ê³µê²©ì )
                const chaseThreshold = p.weaponType === 'melee' ? 0.8 : 0.95;
                if (sit.enemyDist > getPlayerRange(p) * chaseThreshold && sit.advantage > 1.2) {
                    const dx = sit.nearestEnemy.x - p.x;
                    const dy = sit.nearestEnemy.y - p.y;
                    aiDash(p, dx, dy);
                }
                
                aiDoAttack(p, sit.nearestEnemy, dt);
                return;
            }
        }
        
        // ===== í‰ìƒì‹œ: ë…¸ë“œ ì¤‘ì•™ ë”°ë¼ ì´ë™ =====
        
        // ëª©í‘œ ë…¸ë“œ ì—†ìœ¼ë©´ ì„ íƒ
        if (!p.targetNode) {
            p.targetNode = feSelectTargetNode(p);
        }
        
        // í˜„ì¬ ë…¸ë“œ ì—†ìœ¼ë©´ ì°¾ê¸°
        if (!p.currentNode) {
            p.currentNode = findCurrentNode(p);
        }
        
        // ëª©í‘œ ë…¸ë“œ ì •ë³´
        const targetNodeObj = game.nodes[p.targetNode];
        
        // ëª©í‘œ ë…¸ë“œ ë„ì°© ì²´í¬
        if (targetNodeObj && distance(p, targetNodeObj) < CONFIG.CHANNEL_RANGE) {
            // ì±„ë„ë§ ê°€ëŠ¥í•˜ë©´ ì‹œë„
            if (canAttackNode(targetNodeObj, p.team)) {
                aiStartChanneling(p, p.targetNode);
                return;
            } else {
                // ì±„ë„ë§ ë¶ˆê°€ (ì´ë¯¸ ì ë ¹ë¨ ë“±) â†’ í˜„ì¬ ë…¸ë“œ ê°±ì‹  + ìƒˆ ëª©í‘œ ì„ íƒ
                p.currentNode = p.targetNode;
                p.targetNode = feSelectTargetNode(p);
                // return í•˜ì§€ ì•Šê³  ê³„ì† ì§„í–‰í•´ì„œ ë°”ë¡œ ì´ë™ ì‹œì‘
            }
        }
        
        // ëª©í‘œ ë…¸ë“œê°€ ë” ì´ìƒ ê³µê²© ë¶ˆê°€ë©´ ìƒˆ ëª©í‘œ ì„ íƒ
        if (p.targetNode && !canAttackNode(game.nodes[p.targetNode], p.team)) {
            p.targetNode = feSelectTargetNode(p);
        }
        
        // ë‹¤ìŒ ë…¸ë“œë¡œ ì´ë™
        if (p.currentNode && p.targetNode && p.currentNode !== p.targetNode) {
            const nextNode = getNextNode(p.currentNode, p.targetNode);
            moveToNode(p, nextNode, speed, dt);
        } else if (p.targetNode) {
            moveToNode(p, p.targetNode, speed, dt);
        }
    }
    function findNearestEnemy(p) {
        let nearest = null;
        let minDist = Infinity;
        
        for (const other of game.players) {
            if (other.team === p.team || !other.alive) continue;
            // ë¶€ì‰¬ ì•ˆì— ìˆìœ¼ë©´ ë³¼ ìˆ˜ ì—†ìŒ
            if (!canSeeTarget(p, other)) continue;
            const d = distance(p, other);
            if (d < minDist) {
                minDist = d;
                nearest = other;
            }
        }
        return nearest;
    }
    
    function tryAttack(p) {
        // ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ ë²”ìœ„ ë‚´ ì  ì°¾ê¸°
        const target = findNearestEnemy(p);
        if (target && distance(p, target) < getPlayerRange(p)) {
            attack(p, target);
        }
    }
    
    function attack(attacker, target) {
        attacker.attackCooldown = CONFIG.ATTACK_COOLDOWN;
        const damage = getPlayerDamage(attacker);
        
        // ê³µê²© ì´í™íŠ¸ ì¶”ê°€
        game.attackEffects.push({
            x1: attacker.x,
            y1: attacker.y,
            x2: target.x,
            y2: target.y,
            team: attacker.team,
            timer: 0.15,  // 0.15ì´ˆ ì§€ì†
        });
        
        // ì±„ë„ë§ ì¤‘ì´ë©´ ë³´í˜¸ë§‰ ë¨¼ì € ê³µê²© (ë°©ì–´ë ¥ ì ìš© X)
        if (target.channeling && target.channelShield > 0) {
            target.channelShield -= damage;
            
            // ë³´í˜¸ë§‰ ê¹¨ì§ â†’ ì±„ë„ë§ ì‹¤íŒ¨ + í›„ë”œë ˆì´
            if (target.channelShield <= 0) {
                failChanneling(target);
            }
            return;  // ë³´í˜¸ë§‰ ê³µê²©ì€ HP ì•ˆ ê¹ìŒ
        }
        
        // í”¼ê²© ì‹œ ê·€í™˜ ì·¨ì†Œ
        if (target.recalling) {
            target.recalling = false;
            target.recallProgress = 0;
        }
        
        // ë°©ì–´ë ¥ ì ìš©ëœ ë°ë¯¸ì§€
        const armor = WEAPON_SPECS[target.weaponType].armor;
        const finalDamage = damage * (1 - armor);
        
        target.hp -= finalDamage;
        
        if (target.hp <= 0) {
            target.alive = false;
            target.hp = 0;
            
            // ë¦¬ìŠ¤í° íƒ€ì„: 6 + 2 Ã— íŒ€ë ˆë²¨
            const targetTeamLevel = getTeamLevel(target.team);
            target.respawnTimer = 6 + 2 * targetTeamLevel;
            
            cancelChanneling(target);
            
            // í‚¬ XP íšë“
            addTeamXP(attacker.team, CONFIG.KILL_XP);
        }
    }
    
    function respawn(p) {
        p.alive = true;
        p.hp = p.maxHp;
        p.recalling = false;
        p.recallProgress = 0;
        
        // AI ìƒíƒœ ë¦¬ì…‹
        p.currentNode = p.team === 0 ? 'A_Guardian' : 'B_Guardian';
        p.targetNode = null;
        
        // ìŠ¤í° ìœ„ì¹˜ - ë² ì´ìŠ¤ ì •ì¤‘ì•™
        const base = game.nodes[p.team === 0 ? 'A_Base' : 'B_Base'];
        p.x = base.x;
        p.y = base.y;
    }
    
    function distance(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }
    
    // ==================== ë Œë”ë§ ====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    
    function toPixel(x, y) {
        return [
            (x - camera.x) * CONFIG.SCALE,
            (y - camera.y) * CONFIG.SCALE
        ];
    }
    
    function render() {
        // ê²Œì„ ìƒíƒœ ì²´í¬
        if (!game.players || game.players.length === 0 || Object.keys(game.nodes).length === 0) {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = '#fff';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('ì„œë²„ ì—°ê²° ëŒ€ê¸° ì¤‘...', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            return;
        }
        
        // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (ë‚´ í”Œë ˆì´ì–´ ë”°ë¼ê°€ê¸°)
        const me = getMyPlayer();
        if (me) {
            camera.x = me.x - (CONFIG.SCREEN_WIDTH / CONFIG.SCALE) / 2;
            camera.y = me.y - (CONFIG.SCREEN_HEIGHT / CONFIG.SCALE) / 2;
            camera.x = Math.max(0, Math.min(CONFIG.MAP_WIDTH - CONFIG.SCREEN_WIDTH / CONFIG.SCALE, camera.x));
            camera.y = Math.max(0, Math.min(CONFIG.MAP_HEIGHT - CONFIG.SCREEN_HEIGHT / CONFIG.SCALE, camera.y));
        }
        
        // ë°°ê²½
        ctx.fillStyle = '#0d1117';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // ë„ë¡œ ì˜ì—­ (15m í­)
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'rgba(40, 44, 52, 0.8)';
        ctx.lineWidth = CONFIG.LANE_WIDTH * CONFIG.SCALE;
        for (const [from, to] of NODE_CONNECTIONS) {
            const n1 = game.nodes[from];
            const n2 = game.nodes[to];
            if (!n1 || !n2) continue;
            const [x1, y1] = toPixel(n1.x, n1.y);
            const [x2, y2] = toPixel(n2.x, n2.y);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        
        // ë„ë¡œ ê°€ì¥ìë¦¬ ë¼ì¸
        ctx.strokeStyle = 'rgba(60, 64, 72, 0.5)';
        ctx.lineWidth = CONFIG.LANE_WIDTH * CONFIG.SCALE;
        ctx.setLineDash([10, 10]);
        for (const [from, to] of NODE_CONNECTIONS) {
            const n1 = game.nodes[from];
            const n2 = game.nodes[to];
            const [x1, y1] = toPixel(n1.x, n1.y);
            const [x2, y2] = toPixel(n2.x, n2.y);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        
        // ë„ë¡œ ì¤‘ì•™ì„ 
        ctx.strokeStyle = '#2a2a3a';
        ctx.lineWidth = 2;
        for (const [from, to] of NODE_CONNECTIONS) {
            const n1 = game.nodes[from];
            const n2 = game.nodes[to];
            const [x1, y1] = toPixel(n1.x, n1.y);
            const [x2, y2] = toPixel(n2.x, n2.y);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        
        // ë¶€ì‰¬
        for (const bush of BUSHES) {
            const [cx, cy] = toPixel(bush.x, bush.y);
            const radius = bush.radius * CONFIG.SCALE;
            
            // í™”ë©´ ë°–ì´ë©´ ìŠ¤í‚µ
            if (cx < -100 || cx > CANVAS_WIDTH + 100 || cy < -100 || cy > CANVAS_HEIGHT + 100) continue;
            
            // ë¶€ì‰¬ ë°°ê²½ (ì´ˆë¡ ê·¸ë¼ë°ì´ì…˜)
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
            gradient.addColorStop(0, 'rgba(39, 174, 96, 0.6)');
            gradient.addColorStop(0.7, 'rgba(39, 174, 96, 0.4)');
            gradient.addColorStop(1, 'rgba(39, 174, 96, 0.1)');
            
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // ë¶€ì‰¬ í…Œë‘ë¦¬ (ì ì„ )
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(39, 174, 96, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // ë…¸ë“œ
        for (const [id, node] of Object.entries(game.nodes)) {
            const [cx, cy] = toPixel(node.x, node.y);
            
            // í™”ë©´ ë°–ì´ë©´ ìŠ¤í‚µ
            if (cx < -100 || cx > CANVAS_WIDTH + 100 || cy < -100 || cy > CANVAS_HEIGHT + 100) continue;
            
            const radius = NODE_SPECS[node.tier].radius * CONFIG.SCALE;
            const isLocked = node.locked;
            
            // íŒ€ ìƒ‰ìƒ
            let color;
            if (node.owner === 0) color = '#3498db';
            else if (node.owner === 1) color = '#e74c3c';
            else if (node.tier === 'Breaker') color = '#9b59b6';
            else color = '#555';
            
            // ì ê¸´ ë…¸ë“œëŠ” ì–´ë‘¡ê²Œ
            if (isLocked) {
                color = '#333';
            }
            
            // ì™¸ê³½
            ctx.beginPath();
            ctx.arc(cx, cy, radius + 2, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            
            // ë‚´ë¶€
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#1a1a2e';
            ctx.fill();
            
            // ì ê¸´ ë…¸ë“œëŠ” ìë¬¼ì‡  ì•„ì´ì½˜ í‘œì‹œ
            if (isLocked) {
                ctx.fillStyle = '#666';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ”’', cx, cy + 5);
            } else {
                // ì¤‘ì•™ì  (ì±„ë„ë§ ìœ„ì¹˜)
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                // ì¤‘ì•™ ì‹­ì
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx - 8, cy);
                ctx.lineTo(cx + 8, cy);
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx, cy + 8);
                ctx.stroke();
                
                // ì±„ë„ë§ ë²”ìœ„ í‘œì‹œ (1m = 25px)
                ctx.beginPath();
                ctx.arc(cx, cy, CONFIG.CHANNEL_RANGE * CONFIG.SCALE, 0, Math.PI * 2);
                ctx.strokeStyle = color + '40';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ë…¸ë“œ ê³µê²© ë²”ìœ„ í‘œì‹œ (DPS > 0ì¸ ê²½ìš°)
                const spec = NODE_SPECS[node.tier];
                if (spec.dps > 0 && spec.range > 0) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, spec.range * CONFIG.SCALE, 0, Math.PI * 2);
                    ctx.strokeStyle = color + '20';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // í‹°ì–´ í…ìŠ¤íŠ¸
            ctx.fillStyle = '#8b949e';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(node.tier, cx, cy + radius + 15);
        }
        
        // í…”ë ˆí¬íŠ¸ íŒ¨ë„ ë Œë”ë§
        for (const [panelId, panel] of Object.entries(TELEPORT_PANELS)) {
            const [cx, cy] = toPixel(panel.x, panel.y);
            const radius = TELEPORT_PANEL_RADIUS * CONFIG.SCALE;
            
            // í™”ë©´ ë°–ì´ë©´ ìŠ¤í‚µ
            if (cx < -50 || cx > CANVAS_WIDTH + 50 || cy < -50 || cy > CANVAS_HEIGHT + 50) continue;
            
            // íŒ¨ë„ ìƒíƒœ í™•ì¸
            const status = getTeleportPanelStatus(panelId);
            const targetNode = game.nodes[panel.targetNode];
            
            // ìƒ‰ìƒ ê²°ì •
            let color, glowColor;
            if (status === 'ally') {
                color = '#3498db';  // íŒŒë‘ (ì•„êµ° ì ë ¹, í…”í¬ ê°€ëŠ¥)
                glowColor = 'rgba(52, 152, 219, 0.4)';
            } else if (status === 'enemy') {
                color = '#e74c3c';  // ë¹¨ê°• (ì  ì ë ¹)
                glowColor = 'rgba(231, 76, 60, 0.2)';
            } else {
                color = '#555';     // íšŒìƒ‰ (ì¤‘ë¦½)
                glowColor = 'rgba(85, 85, 85, 0.2)';
            }
            
            // ê¸€ë¡œìš° íš¨ê³¼ (í…”í¬ ê°€ëŠ¥í•  ë•Œë§Œ)
            if (status === 'ally') {
                const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius * 1.5);
                gradient.addColorStop(0, glowColor);
                gradient.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            // íŒ¨ë„ ì›
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = color + '30';  // ë°˜íˆ¬ëª…
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // í…”í¬ ì•„ì´ì½˜ (í™”ì‚´í‘œ)
            ctx.fillStyle = color;
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â¬†', cx, cy);
            
            // ëª©í‘œ ë…¸ë“œ ì´ë¦„ (ì‘ê²Œ)
            ctx.fillStyle = '#8b949e';
            ctx.font = '10px monospace';
            ctx.fillText(panel.targetNode.replace('_', ''), cx, cy + radius + 10);
        }
        
        // ê³µê²© ì´í™íŠ¸ (ë¹”)
        for (const atk of game.attackEffects) {
            const [x1, y1] = toPixel(atk.x1, atk.y1);
            const [x2, y2] = toPixel(atk.x2, atk.y2);
            const alpha = atk.timer / 0.15;  // í˜ì´ë“œì•„ì›ƒ
            
            const color = atk.team === 0 ? '52, 152, 219' : '231, 76, 60';
            
            // ê¸€ë¡œìš° íš¨ê³¼
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = `rgba(${color}, ${alpha * 0.3})`;
            ctx.lineWidth = 8;
            ctx.stroke();
            
            // ë©”ì¸ ë¹”
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = `rgba(${color}, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // ì¤‘ì•™ ì½”ì–´
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // íƒ€ê²© ì§€ì  ë°˜ì§ì„
            ctx.beginPath();
            ctx.arc(x2, y2, 5 + (1 - alpha) * 10, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
            ctx.fill();
        }
        
        // ëŒ€ì‹œ ì´í™íŠ¸ (ì”ìƒ)
        for (const dash of game.dashEffects) {
            const [x1, y1] = toPixel(dash.x1, dash.y1);
            const [x2, y2] = toPixel(dash.x2, dash.y2);
            const alpha = dash.timer / 0.2;  // í˜ì´ë“œì•„ì›ƒ
            
            const color = dash.team === 0 ? '52, 152, 219' : '231, 76, 60';
            
            // ì”ìƒ ë¼ì¸ (ì ì„  ëŠë‚Œ)
            ctx.beginPath();
            ctx.setLineDash([10, 5]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = `rgba(${color}, ${alpha * 0.6})`;
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ì‹œì‘ì  ì”ìƒ ì›
            ctx.beginPath();
            ctx.arc(x1, y1, 8 * alpha, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${color}, ${alpha * 0.4})`;
            ctx.fill();
            
            // ë„ì°©ì  ë²ˆì©ì„
            ctx.beginPath();
            ctx.arc(x2, y2, 12 * (1 - alpha) + 5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
            ctx.fill();
        }
        
        // ê¶ê·¹ê¸° ì´í™íŠ¸
        for (const ult of game.ultEffects) {
            const [cx, cy] = toPixel(ult.x, ult.y);
            const radius = ult.radius * CONFIG.SCALE;
            const alpha = ult.timer / 0.5;  // í˜ì´ë“œì•„ì›ƒ
            
            const color = ult.team === 0 ? '52, 152, 219' : '231, 76, 60';
            
            // ì™¸ê³½ ë§
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${color}, ${alpha})`;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // ë‚´ë¶€ ì±„ìš°ê¸°
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${color}, ${alpha * 0.3})`;
            ctx.fill();
            
            // ì¤‘ì•™ ë³„
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.font = `${20 + (1 - alpha) * 20}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('âœ¦', cx, cy + 8);
        }
        
        // ìŠ¤í‚¬ ì¡°ì¤€ ë¯¸ë¦¬ë³´ê¸°
        const aimMe = getMyPlayer();
        if (aimMe.alive) {
            const [myCx, myCy] = toPixel(aimMe.x, aimMe.y);
            const mouseWorldX = camera.x + input.mouseX / CONFIG.SCALE;
            const mouseWorldY = camera.y + input.mouseY / CONFIG.SCALE;
            const [mousePixelX, mousePixelY] = toPixel(mouseWorldX, mouseWorldY);
            
            // ê¶ê·¹ê¸° ì¡°ì¤€ ë¯¸ë¦¬ë³´ê¸°
            if (input.aimingUlt) {
                const spec = WEAPON_SPECS[aimMe.weaponType];
                const radius = spec.ultRadius * CONFIG.SCALE;
                let targetX, targetY;
                
                if (aimMe.weaponType === 'melee') {
                    targetX = myCx;
                    targetY = myCy;
                } else {
                    targetX = mousePixelX;
                    targetY = mousePixelY;
                }
                
                // ë²”ìœ„ ì›
                ctx.beginPath();
                ctx.arc(targetX, targetY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(241, 196, 15, 0.8)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ë‚´ë¶€ ì±„ìš°ê¸°
                ctx.beginPath();
                ctx.arc(targetX, targetY, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(241, 196, 15, 0.2)';
                ctx.fill();
                
                // í…ìŠ¤íŠ¸
                ctx.fillStyle = '#f1c40f';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Q - í´ë¦­í•˜ì—¬ ë°œë™', targetX, targetY - radius - 10);
            }
            
            // ëŒ€ì‹œ ì¡°ì¤€ ë¯¸ë¦¬ë³´ê¸°
            if (input.aimingDash) {
                const spec = WEAPON_SPECS[aimMe.weaponType];
                
                // ë°©í–¥ ê³„ì‚°
                let dirX = mouseWorldX - aimMe.x;
                let dirY = mouseWorldY - aimMe.y;
                const len = Math.sqrt(dirX * dirX + dirY * dirY);
                
                if (len > 0) {
                    const dx = (dirX / len) * spec.dashDist;
                    const dy = (dirY / len) * spec.dashDist;
                    
                    let dashX = aimMe.x + dx;
                    let dashY = aimMe.y + dy;
                    
                    if (!isOnRoad(dashX, dashY)) {
                        const nearest = getNearestRoadPosition(dashX, dashY);
                        dashX = nearest.x;
                        dashY = nearest.y;
                    }
                    
                    const [dashPixelX, dashPixelY] = toPixel(dashX, dashY);
                    
                    // ëŒ€ì‹œ ë¼ì¸
                    ctx.beginPath();
                    ctx.moveTo(myCx, myCy);
                    ctx.lineTo(dashPixelX, dashPixelY);
                    ctx.strokeStyle = 'rgba(46, 204, 113, 0.8)';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([10, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // ë„ì°©ì  ì›
                    ctx.beginPath();
                    ctx.arc(dashPixelX, dashPixelY, 15, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(46, 204, 113, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
                    ctx.fill();
                    
                    // í…ìŠ¤íŠ¸
                    ctx.fillStyle = '#2ecc71';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('E - í´ë¦­í•˜ì—¬ ë°œë™', dashPixelX, dashPixelY - 25);
                }
            }
        }
        
        // í”Œë ˆì´ì–´
        const myTeamId = getMyPlayer().team;  // ë‚´ íŒ€
        
        for (const p of game.players) {
            if (!p.alive) continue;
            
            // ì „ì¥ì˜ ì•ˆê°œ: ì ì€ ì‹œì•¼ ë‚´ì—ì„œë§Œ ë³´ì„
            if (p.team !== myTeamId && !isVisibleToTeam(p, myTeamId)) {
                continue;
            }
            
            const [cx, cy] = toPixel(p.x, p.y);
            
            // í™”ë©´ ë°–ì´ë©´ ìŠ¤í‚µ
            if (cx < -50 || cx > CANVAS_WIDTH + 50 || cy < -50 || cy > CANVAS_HEIGHT + 50) continue;
            
            const radius = CONFIG.PLAYER_RADIUS * CONFIG.SCALE;
            const color = p.team === 0 ? '#3498db' : '#e74c3c';
            const isMe = p.id === myPlayerId;
            
            // ë³¸ì¸ ê³µê²© ì‚¬ê±°ë¦¬ í‘œì‹œ
            if (isMe) {
                ctx.beginPath();
                ctx.arc(cx, cy, getPlayerRange(p) * CONFIG.SCALE, 0, Math.PI * 2);
                ctx.fillStyle = color + '15';  // ì€ì€í•˜ê²Œ
                ctx.fill();
                ctx.strokeStyle = color + '40';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // ì±„ë„ë§ ë³´í˜¸ë§‰ í‘œì‹œ
            if (p.channeling && p.channelShield > 0 && p.maxChannelShield > 0) {
                const shieldRatio = p.channelShield / p.maxChannelShield;
                ctx.beginPath();
                ctx.arc(cx, cy, radius + 8, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(155, 89, 182, ${0.3 + shieldRatio * 0.7})`;  // ë³´ë¼ìƒ‰
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // ìœ¡ê°í˜• ë³´í˜¸ë§‰ ëŠë‚Œ
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * (radius + 10);
                    const y = cy + Math.sin(angle) * (radius + 10);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.strokeStyle = `rgba(155, 89, 182, ${shieldRatio})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // ìŠ¤í„´ í‘œì‹œ (ë³„ ëŒì•„ê°€ëŠ” íš¨ê³¼)
            if (p.stunTimer > 0) {
                const starCount = 3;
                const orbitRadius = radius + 12;
                const spinSpeed = game.tick * 0.15;
                
                for (let i = 0; i < starCount; i++) {
                    const angle = spinSpeed + (i / starCount) * Math.PI * 2;
                    const sx = cx + Math.cos(angle) * orbitRadius;
                    const sy = cy + Math.sin(angle) * orbitRadius;
                    
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('â˜…', sx, sy + 4);
                }
                
                ctx.fillStyle = '#f1c40f';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('STUNNED', cx, cy - radius - 12);
            }
            
            // ë¦¬ì½œ ì´í™íŠ¸ (í™•ì¥ ì›í˜• íŒŒë™)
            if (p.recalling) {
                const progress = p.recallProgress / CONFIG.RECALL_TIME;
                
                // í„ìŠ¤ íš¨ê³¼ (ì‹œê°„ì— ë”°ë¼ í™•ì¥)
                const pulsePhase = (game.tick * 0.1) % 1;
                const pulseRadius = radius + 5 + pulsePhase * 25;
                const pulseAlpha = 0.6 * (1 - pulsePhase);
                
                ctx.beginPath();
                ctx.arc(cx, cy, pulseRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(52, 152, 219, ${pulseAlpha})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // ë‚´ë¶€ ì› (ì§„í–‰ë„ í‘œì‹œ)
                ctx.beginPath();
                ctx.arc(cx, cy, radius + 6, -Math.PI/2, -Math.PI/2 + progress * Math.PI * 2);
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // í”Œë ˆì´ì–´ ì›
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = isMe ? '#fff' : '#000';
            ctx.lineWidth = isMe ? 2 : 1;
            ctx.stroke();
            
            // HP ë°”
            const hpRatio = p.hp / p.maxHp;
            ctx.fillStyle = '#333';
            ctx.fillRect(cx - 15, cy - radius - 8, 30, 4);
            ctx.fillStyle = hpRatio > 0.5 ? '#2ecc71' : hpRatio > 0.25 ? '#f1c40f' : '#e74c3c';
            ctx.fillRect(cx - 15, cy - radius - 8, 30 * hpRatio, 4);
            
            // AI í‘œì‹œ
            if (p.isAI) {
                ctx.fillStyle = '#fff';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('AI', cx, cy + 3);
            }
            
            // ì±„ë„ë§ ê²Œì´ì§€
            if (p.channeling) {
                const barWidth = 50;
                const barHeight = 6;
                // AIëŠ” 0~1 ê¸°ë°˜, í”Œë ˆì´ì–´ëŠ” ì‹œê°„ ê¸°ë°˜
                const progress = p.isAI ? p.channelProgress : (p.channelTime > 0 ? p.channelProgress / p.channelTime : 0);
                const shieldRatio = p.maxChannelShield > 0 ? p.channelShield / p.maxChannelShield : 0;
                
                // ë³´í˜¸ë§‰ ë°” (ìœ„)
                ctx.fillStyle = '#333';
                ctx.fillRect(cx - barWidth/2, cy + radius + 8, barWidth, barHeight);
                ctx.fillStyle = '#9b59b6';  // ë³´ë¼ìƒ‰
                ctx.fillRect(cx - barWidth/2, cy + radius + 8, barWidth * shieldRatio, barHeight);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(cx - barWidth/2, cy + radius + 8, barWidth, barHeight);
                
                // ì±„ë„ë§ ì§„í–‰ ë°” (ì•„ë˜)
                ctx.fillStyle = '#333';
                ctx.fillRect(cx - barWidth/2, cy + radius + 16, barWidth, barHeight);
                ctx.fillStyle = '#2ecc71';  // ì´ˆë¡ìƒ‰
                ctx.fillRect(cx - barWidth/2, cy + radius + 16, barWidth * progress, barHeight);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(cx - barWidth/2, cy + radius + 16, barWidth, barHeight);
                
                // "HACKING" í…ìŠ¤íŠ¸
                ctx.fillStyle = '#9b59b6';
                ctx.font = 'bold 10px monospace';
                ctx.fillText('HACKING', cx, cy + radius + 36);
            }
            
            // ê·€í™˜ ê²Œì´ì§€ í‘œì‹œ
            if (p.recalling) {
                const progress = p.recallProgress / CONFIG.RECALL_TIME;
                const barWidth = 40;
                const barHeight = 6;
                
                // ê·€í™˜ ì§„í–‰ ë°”
                ctx.fillStyle = '#333';
                ctx.fillRect(cx - barWidth/2, cy + radius + 8, barWidth, barHeight);
                ctx.fillStyle = '#3498db';  // íŒŒë€ìƒ‰
                ctx.fillRect(cx - barWidth/2, cy + radius + 8, barWidth * progress, barHeight);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(cx - barWidth/2, cy + radius + 8, barWidth, barHeight);
                
                // "RECALL" í…ìŠ¤íŠ¸
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 10px monospace';
                ctx.fillText('RECALL', cx, cy + radius + 24);
            }
        }
        
        // ì „ì¥ì˜ ì•ˆê°œ
        renderFogOfWar();
        
        // ë¯¸ë‹ˆë§µ
        renderMinimap();
        
        // ì•Œë¦¼
        renderNotifications();
        
        // UI ì—…ë°ì´íŠ¸
        updateUI();
        
        // ë¦¬ìŠ¤í° ëŒ€ê¸° í™”ë©´
        if (me && !me.alive && game.winner === null) {
            // ë°˜íˆ¬ëª… ì˜¤ë²„ë ˆì´
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ë¦¬ìŠ¤í° í…ìŠ¤íŠ¸
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('YOU DIED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 36px sans-serif';
            ctx.fillText(`Respawn in ${me.respawnTimer.toFixed(1)}s`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
        }
        
        // ìŠ¹ë¦¬ í™”ë©´
        if (game.winner !== null) {
            // ë°˜íˆ¬ëª… ì˜¤ë²„ë ˆì´
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ìŠ¹ë¦¬ í…ìŠ¤íŠ¸
            const winnerText = game.winner === 0 ? 'BLUE TEAM WINS!' : 'RED TEAM WINS!';
            const winnerColor = game.winner === 0 ? '#3498db' : '#e74c3c';
            
            ctx.fillStyle = winnerColor;
            ctx.font = 'bold 64px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(winnerText, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = '24px sans-serif';
            ctx.fillText(`Time: ${game.time.toFixed(1)}s`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
            
            ctx.fillStyle = '#888';
            ctx.font = '18px sans-serif';
            ctx.fillText('Press R to restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 70);
        }
    }
    
    function renderFogOfWar() {
        const myTeamId = getMyPlayer().team;
        
        // ì˜¤í”„ìŠ¤í¬ë¦° ìº”ë²„ìŠ¤ë¡œ ë§ˆìŠ¤í¬ ìƒì„±
        const fogCanvas = document.createElement('canvas');
        fogCanvas.width = CANVAS_WIDTH;
        fogCanvas.height = CANVAS_HEIGHT;
        const fogCtx = fogCanvas.getContext('2d');
        
        // ì „ì²´ ì–´ë‘¡ê²Œ
        fogCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        fogCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // ì•„êµ° ì‹œì•¼ ì˜ì—­ ì§€ìš°ê¸°
        fogCtx.globalCompositeOperation = 'destination-out';
        for (const p of game.players) {
            if (p.team !== myTeamId || !p.alive) continue;
            const [cx, cy] = toPixel(p.x, p.y);
            const visionRadius = CONFIG.VISION_RANGE * CONFIG.SCALE;
            
            // ê·¸ë¼ë°ì´ì…˜ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ
            const gradient = fogCtx.createRadialGradient(cx, cy, visionRadius * 0.7, cx, cy, visionRadius);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            fogCtx.fillStyle = gradient;
            fogCtx.beginPath();
            fogCtx.arc(cx, cy, visionRadius, 0, Math.PI * 2);
            fogCtx.fill();
        }
        
        // ë©”ì¸ ìº”ë²„ìŠ¤ì— ì•ˆê°œ ë ˆì´ì–´ í•©ì„±
        ctx.drawImage(fogCanvas, 0, 0);
    }
    
    function renderMinimap() {
        const mx = CANVAS_WIDTH - CONFIG.MINIMAP_SIZE - CONFIG.MINIMAP_MARGIN;
        const my = CONFIG.MINIMAP_MARGIN;
        const scale = CONFIG.MINIMAP_SIZE / CONFIG.MAP_WIDTH;
        
        // ë°°ê²½
        ctx.fillStyle = 'rgba(13, 17, 23, 0.9)';
        ctx.fillRect(mx, my, CONFIG.MINIMAP_SIZE, CONFIG.MINIMAP_SIZE);
        ctx.strokeStyle = '#30363d';
        ctx.lineWidth = 2;
        ctx.strokeRect(mx, my, CONFIG.MINIMAP_SIZE, CONFIG.MINIMAP_SIZE);
        
        // ì—°ê²°ì„ 
        ctx.strokeStyle = '#2a2a3a';
        ctx.lineWidth = 1;
        for (const [from, to] of NODE_CONNECTIONS) {
            const n1 = game.nodes[from];
            const n2 = game.nodes[to];
            ctx.beginPath();
            ctx.moveTo(mx + n1.x * scale, my + n1.y * scale);
            ctx.lineTo(mx + n2.x * scale, my + n2.y * scale);
            ctx.stroke();
        }
        
        // ë¶€ì‰¬
        for (const bush of BUSHES) {
            ctx.beginPath();
            ctx.arc(mx + bush.x * scale, my + bush.y * scale, bush.radius * scale, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(39, 174, 96, 0.4)';
            ctx.fill();
        }
        
        // ë…¸ë“œ
        for (const [id, node] of Object.entries(game.nodes)) {
            let color;
            if (node.owner === 0) color = '#3498db';
            else if (node.owner === 1) color = '#e74c3c';
            else if (node.tier === 'Breaker') color = '#9b59b6';
            else color = '#555';
            
            ctx.beginPath();
            ctx.arc(mx + node.x * scale, my + node.y * scale, 3, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // í…”í¬ íŒ¨ë„ (ë¯¸ë‹ˆë§µ)
        for (const [panelId, panel] of Object.entries(TELEPORT_PANELS)) {
            const status = getTeleportPanelStatus(panelId);
            let color;
            if (status === 'ally') color = '#3498db';
            else if (status === 'enemy') color = '#e74c3c';
            else color = '#555';
            
            ctx.beginPath();
            ctx.rect(mx + panel.x * scale - 2, my + panel.y * scale - 2, 4, 4);
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // í”Œë ˆì´ì–´
        const myTeamId = getMyPlayer().team;
        for (const p of game.players) {
            if (!p.alive) continue;
            
            // ì „ì¥ì˜ ì•ˆê°œ: ì ì€ ì‹œì•¼ ë‚´ì—ì„œë§Œ ë³´ì„
            if (p.team !== myTeamId && !isVisibleToTeam(p, myTeamId)) {
                continue;
            }
            
            const color = p.team === 0 ? '#3498db' : '#e74c3c';
            const isMe = p.id === myPlayerId;
            
            ctx.beginPath();
            ctx.arc(mx + p.x * scale, my + p.y * scale, isMe ? 4 : 2, 0, Math.PI * 2);
            ctx.fillStyle = isMe ? '#fff' : color;
            ctx.fill();
        }
        
        // ì¹´ë©”ë¼ ë·° ì˜ì—­ í‘œì‹œ
        const viewW = (CONFIG.SCREEN_WIDTH / CONFIG.SCALE) * scale;
        const viewH = (CONFIG.SCREEN_HEIGHT / CONFIG.SCALE) * scale;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(mx + camera.x * scale, my + camera.y * scale, viewW, viewH);
    }
    
    function renderNotifications() {
        // í™”ë©´ ìƒë‹¨ ì¤‘ì•™ì— ì•Œë¦¼ í‘œì‹œ
        const startY = 60;
        const lineHeight = 30;
        
        ctx.textAlign = 'center';
        ctx.font = 'bold 16px "Segoe UI", sans-serif';
        
        for (let i = 0; i < game.notifications.length; i++) {
            const notif = game.notifications[i];
            const y = startY + i * lineHeight;
            const alpha = Math.min(1, notif.timer);  // í˜ì´ë“œì•„ì›ƒ
            
            // ë°°ê²½
            const textWidth = ctx.measureText(notif.text).width;
            ctx.fillStyle = `rgba(13, 17, 23, ${alpha * 0.8})`;
            ctx.fillRect(CANVAS_WIDTH / 2 - textWidth / 2 - 15, y - 18, textWidth + 30, 28);
            
            // í…Œë‘ë¦¬
            ctx.strokeStyle = notif.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.lineWidth = 2;
            ctx.strokeRect(CANVAS_WIDTH / 2 - textWidth / 2 - 15, y - 18, textWidth + 30, 28);
            
            // í…ìŠ¤íŠ¸
            ctx.fillStyle = notif.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.fillText(notif.text, CANVAS_WIDTH / 2, y);
        }
    }
    
    function updateUI() {
        const me = getMyPlayer();
        if (!me) return;
        
        const teamA = game.players.filter(p => p.team === 0 && p.alive).length;
        const teamB = game.players.filter(p => p.team === 1 && p.alive).length;
        
        // íŒ€ ë ˆë²¨/XP
        const myTeam = game.teams[me.team];
        const enemyTeam = game.teams[1 - me.team];
        
        // ë…¸ë“œ ì ë ¹ í˜„í™©
        let nodesA = 0, nodesB = 0, nodesN = 0;
        for (const node of Object.values(game.nodes)) {
            if (node.owner === 0) nodesA++;
            else if (node.owner === 1) nodesB++;
            else nodesN++;
        }
        
        // ë¬´ê¸° ì •ë³´
        const weaponName = me.weaponType === 'melee' ? 'âš”ï¸ Melee' : 'ğŸ¹ Ranged';
        const atBase = isAtBase(me);
        const weaponLevelInfo = `Lv.${me.weaponLevel}`;
        const pointsInfo = me.weaponPoints > 0 ? ` <span style="color:#f1c40f">[3: +${me.weaponPoints}pt]</span>` : '';
        const weaponInfo = atBase ? 
            `${weaponName} ${weaponLevelInfo}${pointsInfo} <span style="color:#2ecc71">[1/2 êµì²´]</span>` : 
            `${weaponName} ${weaponLevelInfo}${pointsInfo}`;
        
        // ëŒ€ì‹œ ì¿¨ë‹¤ìš´
        const dashReady = me.dashCooldown <= 0;
        const dashInfo = dashReady ? 
            '<span style="color:#2ecc71">E: Ready</span>' : 
            `<span style="color:#888">E: ${me.dashCooldown.toFixed(1)}s</span>`;
        
        // ê¶ê·¹ê¸° ìƒíƒœ
        const teamLevel = getTeamLevel(me.team);
        let ultInfo;
        if (teamLevel < ULT_REQUIRED_LEVEL) {
            ultInfo = `<span style="color:#555">Q: Lv${ULT_REQUIRED_LEVEL}â†‘</span>`;
        } else if (me.ultCooldown <= 0) {
            ultInfo = '<span style="color:#f1c40f">Q: Ready</span>';
        } else {
            ultInfo = `<span style="color:#888">Q: ${me.ultCooldown.toFixed(1)}s</span>`;
        }
        
        // HP ë°” ìƒ‰ìƒ
        const hpPercent = me.hp / me.maxHp;
        const hpColor = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f1c40f' : '#e74c3c';
        
        // HP ìƒíƒœ
        let hpInfo = `<span style="color:${hpColor}">${Math.ceil(me.hp)}</span>/${me.maxHp}`;
        if (atBase && me.hp < me.maxHp) {
            hpInfo += ' <span style="color:#2ecc71">+healing</span>';
        }
        
        // ìƒíƒœ í‘œì‹œ
        let statusInfo = '';
        if (input.aimingUlt) {
            statusInfo = `<span style="color:#f1c40f">ğŸ¯ Q ì¡°ì¤€ ì¤‘ - í´ë¦­í•˜ì—¬ ë°œë™</span>`;
        } else if (input.aimingDash) {
            statusInfo = `<span style="color:#2ecc71">ğŸ¯ E ì¡°ì¤€ ì¤‘ - í´ë¦­í•˜ì—¬ ë°œë™</span>`;
        } else if (me.recalling) {
            statusInfo = `<span style="color:#3498db">â³ ê·€í™˜ ì¤‘... ${(CONFIG.RECALL_TIME - me.recallProgress).toFixed(1)}s</span>`;
        } else if (me.channeling) {
            statusInfo = `<span style="color:#9b59b6">ğŸ”“ í•´í‚¹ ì¤‘...</span>`;
        } else if (me.stunTimer > 0) {
            statusInfo = `<span style="color:#f1c40f">âš¡ ìŠ¤í„´ ${me.stunTimer.toFixed(1)}s</span>`;
        } else if (isInBush(me)) {
            statusInfo = `<span style="color:#27ae60">ğŸŒ¿ ì€ì‹  ì¤‘</span>`;
        }
        
        document.getElementById('ui').innerHTML = `
            <div style="margin-bottom:8px;font-size:16px;color:#fff;">â± ${game.time.toFixed(1)}s</div>
            <div style="margin-bottom:6px;">â¤ï¸ HP: ${hpInfo}</div>
            <div style="margin-bottom:6px;">${weaponInfo}</div>
            <div style="margin-bottom:6px;">${dashInfo} | ${ultInfo}</div>
            <div style="margin-bottom:8px;border-top:1px solid #30363d;padding-top:8px;">
                <span style="color:#3498db">ğŸ”µ Lv.${game.teams[0].level}</span> <span style="color:#666">(${game.teams[0].xp}/${CONFIG.XP_PER_LEVEL})</span>
                vs
                <span style="color:#e74c3c">ğŸ”´ Lv.${game.teams[1].level}</span> <span style="color:#666">(${game.teams[1].xp}/${CONFIG.XP_PER_LEVEL})</span>
            </div>
            <div style="margin-bottom:4px;">ğŸ‘¥ Alive: <span style="color:#3498db">${teamA}</span> vs <span style="color:#e74c3c">${teamB}</span></div>
            <div>ğŸ° Nodes: <span style="color:#3498db">${nodesA}</span> / <span style="color:#666">${nodesN}</span> / <span style="color:#e74c3c">${nodesB}</span></div>
            ${game.breakerSpawned ? `<div style="margin-top:4px;color:#9b59b6;">âš¡ BREAKER ${game.nodes['Breaker'].owner === -1 ? 'ACTIVE' : (game.nodes['Breaker'].owner === 0 ? 'ğŸ”µ' : 'ğŸ”´')} ${game.breakerClaimCount > 0 ? `(+${Math.round(getBreakerbuff()*100)}%)` : ''}</div>` : ''}
            ${me.hasBreakerbuff ? `<div style="color:#9b59b6;">ğŸ”‹ Breaker Buff: +${Math.round(getBreakerbuff()*100)}%</div>` : ''}
            ${statusInfo ? `<div style="margin-top:8px;border-top:1px solid #30363d;padding-top:8px;">${statusInfo}</div>` : ''}
        `;
    }
    
    // ==================== ê²Œì„ ë£¨í”„ ====================
    let lastTime = 0;
    
    function gameLoop(currentTime) {
        if (!lastTime) lastTime = currentTime;
        lastTime = currentTime;
        
        if (gameState === 'menu') {
            renderMenu();
        } else if (gameState === 'lobby') {
            renderLobby();
        } else if (gameState === 'playing') {
            // ìœ„ì¹˜ ë³´ê°„ (ë¶€ë“œëŸ½ê²Œ)
            for (const p of game.players) {
                if (p.targetX !== undefined) {
                    p.x += (p.targetX - p.x) * 0.3;
                    p.y += (p.targetY - p.y) * 0.3;
                }
            }
            
            // ì„œë²„ê°€ ê²Œì„ ëŒë¦¼ - í´ë¼ì´ì–¸íŠ¸ëŠ” ë Œë”ë§ë§Œ!
            render();
        }
        
        requestAnimationFrame(gameLoop);
    }
    
    // ==================== ë©”ë‰´ ====================
    function renderMenu() {
        ctx.fillStyle = '#0d1117';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        ctx.fillStyle = '#e6edf3';
        ctx.font = 'bold 72px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('PDA', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 100);
        
        ctx.fillStyle = '#8b949e';
        ctx.font = '24px "Segoe UI", sans-serif';
        ctx.fillText('Plastic Dimension Arena', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);
        
        // ë©€í‹°í”Œë ˆì´ ë²„íŠ¼
        const btnW = 280, btnH = 60;
        const btnX = CANVAS_WIDTH / 2 - btnW / 2;
        const btnY = CANVAS_HEIGHT / 2 + 20;
        
        ctx.fillStyle = '#238636';
        ctx.beginPath();
        ctx.roundRect(btnX, btnY, btnW, btnH, 8);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px "Segoe UI", sans-serif';
        ctx.fillText('ğŸŒ MULTIPLAYER', CANVAS_WIDTH / 2, btnY + 38);
        
        ctx.fillStyle = '#666';
        ctx.font = '16px "Segoe UI", sans-serif';
        ctx.fillText('Click to join server', CANVAS_WIDTH / 2, btnY + btnH + 30);
    }
    
    // ==================== ë¡œë¹„ ====================
    function renderLobby() {
        ctx.fillStyle = '#0d1117';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        ctx.fillStyle = '#e6edf3';
        ctx.font = 'bold 48px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Team Select', CANVAS_WIDTH / 2, 70);
        
        if (isHost) {
            ctx.fillStyle = '#f1c40f';
            ctx.font = '16px "Segoe UI", sans-serif';
            ctx.fillText('ğŸ‘‘ You can START', CANVAS_WIDTH / 2, 95);
        }
        
        // íŒ€ ë°•ìŠ¤
        const boxW = 350, boxH = 500;
        const blueX = CANVAS_WIDTH / 2 - boxW - 50;
        const redX = CANVAS_WIDTH / 2 + 50;
        const boxY = 120;
        
        // ë¸”ë£¨íŒ€
        ctx.strokeStyle = '#3498db';
        ctx.lineWidth = 3;
        ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
        ctx.beginPath();
        ctx.roundRect(blueX, boxY, boxW, boxH, 10);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#3498db';
        ctx.font = 'bold 28px "Segoe UI", sans-serif';
        ctx.fillText('ğŸ”µ BLUE', blueX + boxW/2, boxY + 40);
        
        // ë ˆë“œíŒ€
        ctx.strokeStyle = '#e74c3c';
        ctx.fillStyle = 'rgba(231, 76, 60, 0.1)';
        ctx.beginPath();
        ctx.roundRect(redX, boxY, boxW, boxH, 10);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#e74c3c';
        ctx.fillText('ğŸ”´ RED', redX + boxW/2, boxY + 40);
        
        // í”Œë ˆì´ì–´ ëª©ë¡
        ctx.font = '20px "Segoe UI", sans-serif';
        ctx.textAlign = 'left';
        
        const blues = lobbyPlayers.filter(p => p.team === 0);
        const reds = lobbyPlayers.filter(p => p.team === 1);
        
        for (let i = 0; i < 4; i++) {
            const y = boxY + 80 + i * 50;
            
            if (blues[i]) {
                const isMe = blues[i].id === mySocketId;
                ctx.fillStyle = isMe ? '#fff' : '#8b949e';
                ctx.fillText(`${isMe ? 'â–º ' : '  '}${blues[i].name}${blues[i].isHost ? ' ğŸ‘‘' : ''}`, blueX + 20, y);
            } else {
                ctx.fillStyle = '#444';
                ctx.fillText('  (AI)', blueX + 20, y);
            }
            
            if (reds[i]) {
                const isMe = reds[i].id === mySocketId;
                ctx.fillStyle = isMe ? '#fff' : '#8b949e';
                ctx.fillText(`${isMe ? 'â–º ' : '  '}${reds[i].name}${reds[i].isHost ? ' ğŸ‘‘' : ''}`, redX + 20, y);
            } else {
                ctx.fillStyle = '#444';
                ctx.fillText('  (AI)', redX + 20, y);
            }
        }
        
        // íŒ€ ë³€ê²½ ë²„íŠ¼
        const btnWidth = 120, btnHeight = 40;
        const myTeam = lobbyPlayers.find(p => p.id === mySocketId)?.team;
        
        if (myTeam !== 0) {
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.roundRect(blueX + boxW/2 - btnWidth/2, boxY + boxH - 60, btnWidth, btnHeight, 6);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '16px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Join Blue', blueX + boxW/2, boxY + boxH - 35);
        }
        
        if (myTeam !== 1) {
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.roundRect(redX + boxW/2 - btnWidth/2, boxY + boxH - 60, btnWidth, btnHeight, 6);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '16px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Join Red', redX + boxW/2, boxY + boxH - 35);
        }
        
        // START ë²„íŠ¼ (í˜¸ìŠ¤íŠ¸ë§Œ)
        ctx.textAlign = 'center';
        const bottomY = boxY + boxH + 30;
        
        if (isHost) {
            ctx.fillStyle = '#238636';
            ctx.beginPath();
            ctx.roundRect(CANVAS_WIDTH/2 - 100, bottomY, 200, 50, 8);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px "Segoe UI", sans-serif';
            ctx.fillText('START', CANVAS_WIDTH/2, bottomY + 33);
        } else {
            ctx.fillStyle = '#666';
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillText('Waiting for host...', CANVAS_WIDTH/2, bottomY + 30);
        }
    }
    
    // ==================== ì†Œì¼“ ì—°ê²° ====================
    function connectToServer() {
        console.log('ì„œë²„ ì ‘ì† ì‹œë„!');
        socket = io(SERVER_URL);
        
        socket.on('connect', () => {
            mySocketId = socket.id;
            console.log('ì„œë²„ ì—°ê²°ë¨:', mySocketId);
            socket.emit('join_lobby', { name: 'Player' });
        });
        
        socket.on('lobby_update', (data) => {
            lobbyPlayers = data.players;
            isHost = (data.hostId === mySocketId);
            if (gameState === 'menu') {
                gameState = 'lobby';
            }
            console.log('ë¡œë¹„ ì—…ë°ì´íŠ¸:', lobbyPlayers.length, 'ëª…');
        });
        
        socket.on('game_start', (data) => {
            console.log('ê²Œì„ ì‹œì‘!');
            gameState = 'playing';
            
            // ë‚´ í”Œë ˆì´ì–´ ID ì°¾ê¸°
            const blues = data.players.filter(p => p.team === 0);
            const reds = data.players.filter(p => p.team === 1);
            
            for (let i = 0; i < blues.length && i < 4; i++) {
                if (blues[i].id === mySocketId) {
                    myPlayerId = i;
                    console.log('ë‚´ í”Œë ˆì´ì–´ ID:', myPlayerId, 'íŒ€: ë¸”ë£¨');
                }
            }
            for (let i = 0; i < reds.length && i < 4; i++) {
                if (reds[i].id === mySocketId) {
                    myPlayerId = i + 4;
                    console.log('ë‚´ í”Œë ˆì´ì–´ ID:', myPlayerId, 'íŒ€: ë ˆë“œ');
                }
            }
        });
        
        socket.on('game_state', (state) => {
            syncGameState(state);
        });
        
        socket.on('error', (data) => {
            alert(data.message);
            socket.disconnect();
            gameState = 'menu';
        });
        
        socket.on('game_end', (data) => {
            console.log('ê²Œì„ ì¢…ë£Œ! ìŠ¹ì:', data.winner);
            gameState = 'lobby';
            game.winner = null;
            game.players = [];
            game.nodes = {};
        });
        
        socket.on('connect_error', (err) => {
            console.log('ì—°ê²° ì˜¤ë¥˜:', err.message);
        });
    }
    
    function syncGameState(state) {
        game.tick = state.tick;
        game.time = state.time;
        game.teams = state.teams;
        game.winner = state.winner;
        game.breakerSpawned = state.breakerSpawned;
        game.breakerClaimCount = state.breakerClaimCount;
        
        // ì´í™íŠ¸ ë™ê¸°í™”
        game.ultEffects = state.ultEffects || [];
        game.dashEffects = state.dashEffects || [];
        game.attackEffects = state.attackEffects || [];
        
        // ë‚´ í”Œë ˆì´ì–´ ID ì°¾ê¸°
        for (const sp of state.players) {
            if (sp.socketId === mySocketId) {
                myPlayerId = sp.id;
                break;
            }
        }
        
        // í”Œë ˆì´ì–´ ë™ê¸°í™” (ë³´ê°„ ì ìš©)
        for (const sp of state.players) {
            let p = game.players.find(pl => pl.id === sp.id);
            if (!p) {
                // ìƒˆ í”Œë ˆì´ì–´ ì¶”ê°€
                game.players.push({
                    id: sp.id,
                    team: sp.team,
                    x: sp.x,
                    y: sp.y,
                    targetX: sp.x,
                    targetY: sp.y,
                    hp: sp.hp,
                    maxHp: sp.maxHp,
                    alive: sp.alive,
                    weaponType: sp.weaponType,
                    weaponLevel: sp.weaponLevel,
                    weaponPoints: sp.weaponPoints,
                    dashCooldown: sp.dashCooldown,
                    ultCooldown: sp.ultCooldown,
                    attackCooldown: sp.attackCooldown,
                    stunTimer: sp.stunTimer,
                    channeling: sp.channeling,
                    channelTarget: sp.channelTarget,
                    channelProgress: sp.channelProgress,
                    channelTime: sp.channelTime,
                    channelShield: sp.channelShield,
                    maxChannelShield: sp.maxChannelShield,
                    recalling: sp.recalling,
                    recallProgress: sp.recallProgress,
                    respawnTimer: sp.respawnTimer,
                    isAI: sp.isAI,
                    hasBreakerbuff: sp.hasBreakerbuff,
                });
            } else {
                // ë³´ê°„ íƒ€ê²Ÿ ì„¤ì •
                p.targetX = sp.x;
                p.targetY = sp.y;
                p.hp = sp.hp;
                p.maxHp = sp.maxHp;
                p.alive = sp.alive;
                p.weaponType = sp.weaponType;
                p.weaponLevel = sp.weaponLevel;
                p.weaponPoints = sp.weaponPoints;
                p.dashCooldown = sp.dashCooldown;
                p.ultCooldown = sp.ultCooldown;
                p.attackCooldown = sp.attackCooldown;
                p.stunTimer = sp.stunTimer;
                p.channeling = sp.channeling;
                p.channelTarget = sp.channelTarget;
                p.channelProgress = sp.channelProgress;
                p.channelTime = sp.channelTime;
                p.channelShield = sp.channelShield;
                p.maxChannelShield = sp.maxChannelShield;
                p.recalling = sp.recalling;
                p.recallProgress = sp.recallProgress;
                p.respawnTimer = sp.respawnTimer;
                p.hasBreakerbuff = sp.hasBreakerbuff;
            }
        }
        
        // ë…¸ë“œ ë™ê¸°í™”
        for (const [id, sn] of Object.entries(state.nodes)) {
            if (!game.nodes[id]) {
                game.nodes[id] = sn;
            } else {
                game.nodes[id].owner = sn.owner;
                game.nodes[id].locked = sn.locked;
                game.nodes[id].hp = sn.hp;
                game.nodes[id].maxHp = sn.maxHp;
                game.nodes[id].x = sn.x;
                game.nodes[id].y = sn.y;
                game.nodes[id].tier = sn.tier;
            }
        }
    }
    
    // ì…ë ¥ ì „ì†¡
    setInterval(() => {
        if (gameState === 'playing' && socket) {
            // ë§ˆìš°ìŠ¤ ì›”ë“œ ì¢Œí‘œ ê³„ì‚°
            const mouseWorldX = camera.x + input.mouseX / CONFIG.SCALE;
            const mouseWorldY = camera.y + input.mouseY / CONFIG.SCALE;
            
            // ì¡°ì¤€ + í´ë¦­ = ìŠ¤í‚¬ ë°œë™
            let sendE = false;
            let sendQ = false;
            
            if (input.mouseDown && input.aimingDash) {
                sendE = true;
                input.aimingDash = false;
                input.mouseDown = false;
            }
            if (input.mouseDown && input.aimingUlt) {
                sendQ = true;
                input.aimingUlt = false;
                input.mouseDown = false;
            }
            
            socket.emit('player_input', {
                w: input.w,
                a: input.a,
                s: input.s,
                d: input.d,
                f: input.f,
                b: input.b,
                e: sendE,
                q: sendQ,
                '1': input['1'],
                '2': input['2'],
                '3': input['3'],
                mouseX: mouseWorldX,
                mouseY: mouseWorldY,
                mouseDown: input.mouseDown,
            });
        }
    }, 16);
    
    // í´ë¦­ ì´ë²¤íŠ¸
    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (gameState === 'menu') {
            // ë©€í‹°í”Œë ˆì´ ë²„íŠ¼
            const btnW = 280, btnH = 60;
            const btnX = CANVAS_WIDTH / 2 - btnW / 2;
            const btnY = CANVAS_HEIGHT / 2 + 20;
            
            if (x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH) {
                connectToServer();
            }
        } else if (gameState === 'lobby') {
            const boxW = 350, boxH = 500;
            const blueX = CANVAS_WIDTH / 2 - boxW - 50;
            const redX = CANVAS_WIDTH / 2 + 50;
            const boxY = 120;
            const btnWidth = 120, btnHeight = 40;
            
            // Join Blue
            const blueBtnX = blueX + boxW/2 - btnWidth/2;
            const blueBtnY = boxY + boxH - 60;
            if (x >= blueBtnX && x <= blueBtnX + btnWidth && y >= blueBtnY && y <= blueBtnY + btnHeight) {
                socket.emit('change_team', 0);
            }
            
            // Join Red
            const redBtnX = redX + boxW/2 - btnWidth/2;
            if (x >= redBtnX && x <= redBtnX + btnWidth && y >= blueBtnY && y <= blueBtnY + btnHeight) {
                socket.emit('change_team', 1);
            }
            
            // START
            if (isHost) {
                const startX = CANVAS_WIDTH/2 - 100;
                const startY = boxY + boxH + 30;
                if (x >= startX && x <= startX + 200 && y >= startY && y <= startY + 50) {
                    socket.emit('start_game');
                }
            }
        }
    });
    
    // ==================== ì‹œì‘ ====================
    // ë©€í‹°í”Œë ˆì´ì–´ - ì„œë²„ì—ì„œ ì´ˆê¸°í™”
    requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
